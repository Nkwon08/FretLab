<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FretLab - Guitar Scale & Chord Explorer</title>
    <meta name="description" content="Interactive guitar scale and chord explorer with fretboard visualization">
    <!-- Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      :root { --font-sans: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji'; }
      html, body { font-family: var(--font-sans); }
    </style>
  </head>
  <body class="antialiased">
    <div id="root"></div>

    <!-- React and ReactDOM via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for in-browser JSX transform -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Your component code (inlined for file:// compatibility) -->
    <script type="text/babel" data-presets="env,react">
      /* global React */
      const { useState, useMemo } = React;

      const Sun = ({ size = 20 }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="4"></circle>
          <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"></path>
        </svg>
      );

      const Moon = ({ size = 20 }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      );

      const GuitarScaleExplorer = () => {
        const [rootNote, setRootNote] = useState('C');
        const [scaleType, setScaleType] = useState('major');
        const [showDegrees, setShowDegrees] = useState(false);
        const [darkMode, setDarkMode] = useState(true);
        const [hoveredNote, setHoveredNote] = useState(null);
        const [rootColor, setRootColor] = useState('#ef4444'); // red-500
        const [noteColor, setNoteColor] = useState('#3b82f6'); // blue-500
        const [thirdColor, setThirdColor] = useState('#10b981'); // green-500
        const [chordType, setChordType] = useState('triads'); // triads | sevenths
        const [selectedChord, setSelectedChord] = useState(null);
        const [startFret, setStartFret] = useState(1); // First fret to display
        const [endFret, setEndFret] = useState(21); // Last fret to display
        const [drawingMode, setDrawingMode] = useState(null); // 'draw' | 'erase' | null
        const [drawings, setDrawings] = useState({}); // { 'string-fret': true }
        const [isSidebarOpen, setIsSidebarOpen] = useState(false);
        const [page, setPage] = useState('Home'); // Home | Explorer | FretBoard | Tuner | About
        const imgVersion = useMemo(() => Date.now(), []);

        // --- Metronome ---
        const [bpm, setBpm] = useState(100);
        const [isMetronomeOn, setIsMetronomeOn] = useState(false);
        const metroRef = React.useRef({ audioCtx: null, intervalId: null });
        const click = () => {
          try {
            const ctx = metroRef.current.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            metroRef.current.audioCtx = ctx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(1000, ctx.currentTime);
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.001);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.1);
          } catch (e) {
            /* no-op */
          }
        };
        const startMetronome = () => {
          if (isMetronomeOn) return;
          const ms = Math.max(60_000 / Math.max(20, Math.min(300, bpm)), 50);
          click();
          metroRef.current.intervalId = setInterval(click, ms);
          setIsMetronomeOn(true);
        };
        const stopMetronome = () => {
          if (metroRef.current.intervalId) clearInterval(metroRef.current.intervalId);
          metroRef.current.intervalId = null;
          setIsMetronomeOn(false);
        };
        React.useEffect(() => {
          if (!isMetronomeOn) return;
          if (metroRef.current.intervalId) {
            clearInterval(metroRef.current.intervalId);
            metroRef.current.intervalId = null;
          }
          const ms = Math.max(60_000 / Math.max(20, Math.min(300, bpm)), 50);
          metroRef.current.intervalId = setInterval(click, ms);
          return () => {
            if (metroRef.current.intervalId) clearInterval(metroRef.current.intervalId);
          };
        }, [bpm, isMetronomeOn]);
        // home image state removed (not needed)

        // --- Tuner state ---
        const [isTunerOn, setIsTunerOn] = useState(false);
        const [tunerFreq, setTunerFreq] = useState(0);
        const [tunerNote, setTunerNote] = useState('-');
        const [tunerCents, setTunerCents] = useState(0);
        const [tunerError, setTunerError] = useState(null);
        const tunerRef = React.useRef({
          audioCtx: null,
          analyser: null,
          source: null,
          stream: null,
          rafId: null,
          buf: null,
        });

        // Chromatic note names
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Tuning presets (headstock display, low->high)
        const [tuning, setTuning] = useState('standard'); // standard | dropD | halfStepDown
        const tuningPresets = {
          standard: ['E', 'A', 'D', 'G', 'B', 'E'],
          dropD: ['D', 'A', 'D', 'G', 'B', 'E'],
          halfStepDown: ['D#', 'G#', 'C#', 'F#', 'A#', 'D#'],
        };

        // Headstock selection and confirmation logic
        const [selectedString, setSelectedString] = useState(0); // 0 = lowest string in preset list
        const [stringHoldStart, setStringHoldStart] = useState(null);
        const [stringConfirmed, setStringConfirmed] = useState(false);
        const [autoDetectString, setAutoDetectString] = useState(true);

        // Helpers: note name to midi and freq
        const noteNameToMidi = (name, octave) => {
          const idx = noteNames.indexOf(name);
          if (idx < 0) return null;
          return (octave + 1) * 12 + idx; // MIDI formula
        };
        const midiToFreq = (midi) => 440 * Math.pow(2, (midi - 69) / 12);
        const buildTargetFreqs = (presetKey) => {
          // Default octaves per string low->high for standard: E2 A2 D3 G3 B3 E4
          const baseOctavesStandard = [2,2,3,3,3,4];
          const names = tuningPresets[presetKey];
          if (!names) return [];
          // Adjust low string for dropD and halfStepDown
          const octaves = [...baseOctavesStandard];
          if (presetKey === 'dropD') octaves[0] = 2; // D2
          if (presetKey === 'halfStepDown') {
            // E2->D#2 etc., octaves unchanged
          }
          return names.map((n, i) => {
            const midi = noteNameToMidi(n, octaves[i]);
            return midi != null ? midiToFreq(midi) : null;
          });
        };
        const targetFreqs = buildTargetFreqs(tuning);

        // Pluck sound synth
        const pluckRef = React.useRef({ audioCtx: null });
        const playPluck = (freq, idx = null) => {
          try {
            const ctx = pluckRef.current.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            pluckRef.current.audioCtx = ctx;

            const duration = 2.2;
            const now = ctx.currentTime;

            // Multiple oscillators with detuning for natural beating
            const osc1 = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const osc3 = ctx.createOscillator();
            osc1.type = 'triangle';
            osc2.type = 'triangle';
            osc3.type = 'sine';
            osc1.frequency.setValueAtTime(freq, now);
            osc2.frequency.setValueAtTime(freq * 0.996, now);
            osc3.frequency.setValueAtTime(freq * 2, now); // octave harmonic

            // Realistic guitar string filtering
            const lp1 = ctx.createBiquadFilter();
            lp1.type = 'lowpass';
            lp1.frequency.setValueAtTime(3000, now);
            lp1.frequency.exponentialRampToValueAtTime(1800, now + 0.1);
            lp1.Q.setValueAtTime(0.8, now);

            // Acoustic body resonance peaks
            const body1 = ctx.createBiquadFilter();
            body1.type = 'peaking';
            body1.frequency.setValueAtTime(180 + freq * 0.1, now);
            body1.gain.setValueAtTime(8, now);
            body1.Q.setValueAtTime(2, now);
            const body2 = ctx.createBiquadFilter();
            body2.type = 'peaking';
            body2.frequency.setValueAtTime(300 + freq * 0.15, now);
            body2.gain.setValueAtTime(6, now);
            body2.Q.setValueAtTime(1.5, now);

            // More realistic pick attack (filtered noise)
            const attackLen = 0.08 * ctx.sampleRate;
            const noiseBuf = ctx.createBuffer(1, attackLen, ctx.sampleRate);
            const data = noiseBuf.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / ctx.sampleRate;
              data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 60) * (1 - t / 0.08);
            }
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuf;
            const noiseGain = ctx.createGain();
            noiseGain.gain.setValueAtTime(0.25, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

            // String damping over time
            const damping = ctx.createGain();
            damping.gain.setValueAtTime(1, now);
            damping.gain.exponentialRampToValueAtTime(0.3, now + 0.5);
            damping.gain.exponentialRampToValueAtTime(0.001, now + duration);

            // Master envelope (boost G/B strings louder, D string moderate)
            const gain = ctx.createGain();
            let baseVolume = 0.6;
            if (idx === 3 || idx === 4) baseVolume = 1.0; // G and B strings (idx 3, 4) louder
            else if (idx === 2) baseVolume = 0.85; // D string (idx 2) moderate boost
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(baseVolume, now + 0.008);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            // Subtle stereo chorus for width
            const delay = ctx.createDelay(0.1);
            delay.delayTime.setValueAtTime(0.008, now);
            const feedback = ctx.createGain();
            feedback.gain.setValueAtTime(0.12, now);

            // Connect graph
            osc1.connect(lp1);
            osc2.connect(lp1);
            osc3.connect(lp1);
            noise.connect(noiseGain).connect(lp1);
            lp1.connect(body1).connect(body2).connect(damping).connect(delay);
            delay.connect(feedback).connect(delay);
            body2.connect(gain);
            delay.connect(gain);
            gain.connect(ctx.destination);

            // Start/stop
            osc1.start(now);
            osc2.start(now);
            osc3.start(now);
            noise.start(now);
            osc1.stop(now + duration);
            osc2.stop(now + duration);
            osc3.stop(now + duration);
            noise.stop(now + 0.08);
          } catch (e) {
            /* no-op */
          }
        };

        // Sample-based playback (optional assets)
        const sampleRef = React.useRef({ audioCtx: null, cache: new Map() });
        const getStringNameAndOctave = (presetKey, idx) => {
          const baseOctavesStandard = [2,2,3,3,3,4];
          const names = tuningPresets[presetKey];
          if (!names || idx < 0 || idx >= names.length) return null;
          const octaves = [...baseOctavesStandard];
          if (presetKey === 'dropD') octaves[0] = 2;
          return { name: names[idx], octave: octaves[idx] };
        };
        const playStringSample = async (idx) => {
          try {
            const ctx = sampleRef.current.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            sampleRef.current.audioCtx = ctx;
            const info = getStringNameAndOctave(tuning, idx);
            if (!info) throw new Error('no note info');
            const tuningFolderMap = { standard: 'standard', dropD: 'dropD', halfStepDown: 'halfStepDown' };
            const folder = tuningFolderMap[tuning] || 'standard';
            const fileBase = `assets/samples/${folder}/${encodeURIComponent(info.name + info.octave)}`;
            const tryUrls = [`${fileBase}.mp3`, `${fileBase}.wav`];
            let buffer = null;
            for (const url of tryUrls) {
              const key = url;
              if (sampleRef.current.cache.has(key)) {
                buffer = sampleRef.current.cache.get(key);
                break;
              }
              const res = await fetch(url);
              if (res.ok) {
                const arr = await res.arrayBuffer();
                buffer = await ctx.decodeAudioData(arr.slice(0));
                sampleRef.current.cache.set(key, buffer);
                break;
              }
            }
            if (!buffer) throw new Error('sample not found');
            const src = ctx.createBufferSource();
            src.buffer = buffer;
            const gain = ctx.createGain();
            // Boost G (idx 3) and B (idx 4) strings louder, D (idx 2) moderate boost
            let baseGain = 0.9;
            if (idx === 3 || idx === 4) baseGain = 1.7; // G and B strings louder
            else if (idx === 2) baseGain = 1.4; // D string moderate boost
            gain.gain.setValueAtTime(baseGain, ctx.currentTime);
            src.connect(gain).connect(ctx.destination);
            src.start();
            return true;
          } catch (e) {
            return false;
          }
        };
        const playStringSound = async (idx) => {
          const ok = await playStringSample(idx);
          if (!ok) {
            const tf = targetFreqs && targetFreqs[idx];
            if (tf) playPluck(tf, idx);
          }
        };

        React.useEffect(() => {
          // Reset confirmation when tuning preset or selected string changes
          setStringHoldStart(null);
          setStringConfirmed(false);
        }, [tuning, selectedString]);

        React.useEffect(() => {
          if (!isTunerOn) {
            setStringHoldStart(null);
            setStringConfirmed(false);
            return;
          }
          // Auto-detect likely string based on nearest target frequency
          if (autoDetectString && tunerFreq > 0 && targetFreqs && targetFreqs.length === 6) {
            let bestIdx = selectedString;
            let bestDiff = Infinity;
            for (let i = 0; i < targetFreqs.length; i++) {
              const tf = targetFreqs[i];
              if (!tf) continue;
              const centsDiff = 1200 * Math.log2(tunerFreq / tf);
              const absDiff = Math.abs(centsDiff);
              if (absDiff < bestDiff) {
                bestDiff = absDiff;
                bestIdx = i;
              }
            }
            if (bestIdx !== selectedString) setSelectedString(bestIdx);
          }
          const target = tuningPresets[tuning][selectedString];
          const inTune = target && tunerNote === target && Math.abs(tunerCents) <= 5;
          if (inTune) {
            if (!stringHoldStart) {
              setStringHoldStart(performance.now());
            } else if (!stringConfirmed && performance.now() - stringHoldStart >= 3000) {
              setStringConfirmed(true);
            }
          } else {
            setStringHoldStart(null);
            setStringConfirmed(false);
          }
        }, [tunerNote, tunerCents, tunerFreq, tuning, selectedString, isTunerOn, stringHoldStart, stringConfirmed, autoDetectString, targetFreqs]);

        const freqToNoteInfo = (freq) => {
          if (!freq || !isFinite(freq) || freq <= 0) return null;
          const midi = Math.round(69 + 12 * Math.log2(freq / 440));
          const name = noteNames[(midi + 1200) % 12];
          const noteFreq = 440 * Math.pow(2, (midi - 69) / 12);
          const cents = Math.round(1200 * Math.log2(freq / noteFreq));
          return { name, freq: noteFreq, cents, midi };
        };

        const autoCorrelate = (buf, sampleRate) => {
          // Autocorrelation-based pitch detection
          const SIZE = buf.length;
          let rms = 0;
          for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
          rms = Math.sqrt(rms / SIZE);
          if (rms < 0.01) return -1; // too low signal

          let r1 = 0, r2 = SIZE - 1, thres = 0.2;
          for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
          for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
          buf = buf.slice(r1, r2);
          const newSize = buf.length;
          const c = new Array(newSize).fill(0);
          for (let i = 0; i < newSize; i++) {
            for (let j = 0; j < newSize - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
          }
          let d = 0; while (c[d] > c[d + 1]) d++;
          let maxval = -1, maxpos = -1;
          for (let i = d; i < newSize; i++) {
            if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
          }
          let T0 = maxpos;
          if (T0 > 0 && T0 < newSize - 1) {
            const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            const a = (x1 + x3 - 2 * x2) / 2;
            const b = (x3 - x1) / 2;
            if (a) T0 = T0 - b / (2 * a);
          }
          const freq = sampleRate / T0;
          return freq;
        };

        const startTuner = async () => {
          try {
            setTunerError(null);
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
            const source = audioCtx.createMediaStreamSource(stream);
            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);
            const buf = new Float32Array(analyser.fftSize);
            tunerRef.current = { audioCtx, analyser, source, stream, rafId: null, buf };

            const tick = () => {
              analyser.getFloatTimeDomainData(buf);
              const freq = autoCorrelate(buf, audioCtx.sampleRate);
              if (freq > 0 && isFinite(freq) && freq < 2000) {
                setTunerFreq(freq);
                const info = freqToNoteInfo(freq);
                if (info) {
                  setTunerNote(info.name);
                  setTunerCents(Math.max(-50, Math.min(50, info.cents)));
                }
              }
              tunerRef.current.rafId = requestAnimationFrame(tick);
            };
            setIsTunerOn(true);
            tick();
          } catch (e) {
            setTunerError(String(e && e.message ? e.message : e));
            setIsTunerOn(false);
          }
        };

        const stopTuner = () => {
          const ref = tunerRef.current;
          if (ref.rafId) cancelAnimationFrame(ref.rafId);
          if (ref.stream) ref.stream.getTracks().forEach(t => t.stop());
          if (ref.audioCtx) ref.audioCtx.close();
          tunerRef.current = { audioCtx: null, analyser: null, source: null, stream: null, rafId: null, buf: null };
          setIsTunerOn(false);
          setTunerFreq(0);
          setTunerNote('-');
          setTunerCents(0);
        };

        // sound removed

        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        const strings = [
          { name: 'e', openNote: 4 },
          { name: 'B', openNote: 11 },
          { name: 'G', openNote: 7 },
          { name: 'D', openNote: 2 },
          { name: 'A', openNote: 9 },
          { name: 'E', openNote: 4 }
        ];

        const scales = {
          major: [0, 2, 4, 5, 7, 9, 11],
          minor: [0, 2, 3, 5, 7, 8, 10],
          pentatonicMajor: [0, 2, 4, 7, 9],
          pentatonicMinor: [0, 3, 5, 7, 10],
          blues: [0, 3, 5, 6, 7, 10],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
          melodicMinor: [0, 2, 3, 5, 7, 9, 11]
        };

        const scaleNames = {
          major: 'Major',
          minor: 'Natural Minor',
          pentatonicMajor: 'Pentatonic Major',
          pentatonicMinor: 'Pentatonic Minor',
          blues: 'Blues',
          dorian: 'Dorian',
          phrygian: 'Phrygian',
          lydian: 'Lydian',
          mixolydian: 'Mixolydian',
          locrian: 'Locrian',
          harmonicMinor: 'Harmonic Minor',
          melodicMinor: 'Melodic Minor'
        };

        const getScaleNotes = useMemo(() => {
          const rootIndex = notes.indexOf(rootNote);
          const intervals = scales[scaleType];
          return intervals.map(interval => (rootIndex + interval) % 12);
        }, [rootNote, scaleType]);

        const isNoteInScale = (noteIndex) => {
          return getScaleNotes.includes(noteIndex % 12);
        };

        const getScaleDegree = (noteIndex) => {
          const normalizedNote = noteIndex % 12;
          const degreeIndex = getScaleNotes.indexOf(normalizedNote);
          return degreeIndex !== -1 ? degreeIndex + 1 : null;
        };

        const formatDegree = (degree, noteIndex) => {
          if (!degree) return null;
          
          // Get the interval for this degree in the current scale
          const interval = scales[scaleType][degree - 1];
          
          // Check if this interval is flatted or sharped compared to major scale
          const majorIntervals = scales.major;
          const majorIntervalForThisPosition = majorIntervals[Math.min(degree - 1, majorIntervals.length - 1)];
          
          if (interval < majorIntervalForThisPosition) {
            return `${degree}‚ô≠`;
          } else if (interval > majorIntervalForThisPosition) {
            return `${degree}‚ôØ`;
          }
          
          return degree;
        };

        const getNoteAtFret = (stringOpenNote, fret) => {
          return (stringOpenNote + fret) % 12;
        };

        const isRootNote = (noteIndex) => {
          return noteIndex % 12 === notes.indexOf(rootNote);
        };

        const isToneInChord = (noteIndex) => {
          if (!selectedChord || !selectedChord.pcs) return false;
          const normalizedNote = noteIndex % 12;
          return selectedChord.pcs.includes(normalizedNote);
        };

        const isChordRoot = (noteIndex) => {
          if (!selectedChord) return false;
          return (noteIndex % 12) === selectedChord.pcs[0];
        };

        const isChordThird = (noteIndex) => {
          if (!selectedChord || !selectedChord.pcs || selectedChord.pcs.length < 2) return false;
          return (noteIndex % 12) === selectedChord.pcs[1];
        };


        // --- Chords ---
        const rotateArray = (arr, start) => arr.slice(start).concat(arr.slice(0, start));
        const pcDistance = (a, b) => (b - a + 12) % 12;
        const intervalsToQualityTriad = (iv) => {
          const sig = iv.sort((x,y)=>x-y).join(',');
          if (sig === '0,4,7') return 'maj';
          if (sig === '0,3,7') return 'm';
          if (sig === '0,3,6') return 'dim';
          if (sig === '0,4,8') return 'aug';
          return '';
        };
        const intervalsToQualitySeventh = (iv) => {
          const sig = iv.sort((x,y)=>x-y).join(',');
          if (sig === '0,4,7,11') return 'maj7';
          if (sig === '0,4,7,10') return '7';
          if (sig === '0,3,7,10') return 'm7';
          if (sig === '0,3,6,10') return 'm7b5';
          if (sig === '0,3,6,9') return 'dim7';
          return '7';
        };
        const buildDiatonicChords = useMemo(() => {
          const scalePcs = getScaleNotes; // array of pitch classes (0-11)
          if (!scalePcs || scalePcs.length === 0) return [];
          const chords = [];
          for (let degree = 0; degree < scalePcs.length; degree++) {
            const rotated = rotateArray(scalePcs, degree);
            const stack = chordType === 'sevenths' ? [0,2,4,6] : [0,2,4];
            const chordPcs = stack.map(step => rotated[step % rotated.length]);
            const rootPc = chordPcs[0];
            const intervals = chordPcs.map(pc => pcDistance(rootPc, pc));
            const rootName = notes[rootPc];
            const quality = chordType === 'sevenths' ? intervalsToQualitySeventh(intervals) : intervalsToQualityTriad(intervals);
            chords.push({
              name: `${rootName}${quality}`,
              degree: degree + 1,
              pcs: chordPcs,
              quality,
            });
          }
          return chords;
        }, [getScaleNotes, chordType]);

        const visibleFretCount = Math.max(1, endFret - startFret + 1);

        return (
          <div className={`min-h-screen ${darkMode ? 'bg-[#121212]' : 'bg-gray-100'} transition-colors duration-300`}>
            <div className={`${darkMode ? 'bg-[#1c1c1c] border-[#2c2c2c]' : 'bg-white border-gray-200'} border-b`}>
            
              <div className="container mx-auto px-4 py-4">
                <div className="flex flex-wrap items-center justify-between gap-4">
                  <div className="flex items-center gap-3">
                    <button
                      onClick={() => setIsSidebarOpen(true)}
                      className={`h-10 w-10 grid place-items-center rounded-lg transition-colors ${
                        darkMode ? 'bg-slate-800 hover:bg-slate-700 text-white' : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                      }`}
                      title="Open Menu"
                    >
                      ‚ò∞
                    </button>
                  <h1 className={`text-2xl font-bold ${darkMode ? 'text-slate-100' : 'text-gray-900'}`}>
                    FretLab
                  </h1>
                  </div>
                  
                {(page === 'Explorer' || page === 'FretBoard') && (
                  <div className="flex flex-wrap items-end gap-4">
                    <div className="flex items-end gap-3">
                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Root Note
                      </label>
                      <select
                        value={rootNote}
                        onChange={(e) => setRootNote(e.target.value)}
                        className={`px-3 h-10 text-sm rounded-lg ${
                          darkMode 
                            ? 'bg-slate-800 text-white border-slate-600' 
                            : 'bg-white text-slate-900 border-slate-300'
                        } border focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      >
                        {notes.map(note => (
                          <option key={note} value={note}>{note}</option>
                        ))}
                      </select>
                    </div>
                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                          Scale Type
                      </label>
                      <select
                          value={scaleType}
                          onChange={(e) => setScaleType(e.target.value)}
                        className={`px-3 h-10 text-sm rounded-lg ${
                          darkMode 
                            ? 'bg-slate-800 text-white border-slate-600' 
                            : 'bg-white text-slate-900 border-slate-300'
                        } border focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      >
                          {Object.entries(scaleNames).map(([key, name]) => (
                            <option key={key} value={key}>{name}</option>
                          ))}
                      </select>
                      </div>
                    </div>

                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Chords
                      </label>
                      <select
                        value={chordType}
                        onChange={(e) => setChordType(e.target.value)}
                        className={`px-3 h-10 text-sm rounded-lg ${
                          darkMode 
                            ? 'bg-slate-800 text-white border-slate-600' 
                            : 'bg-white text-slate-900 border-slate-300'
                        } border focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      >
                        <option value="triads">Triads</option>
                        <option value="sevenths">Sevenths</option>
                      </select>
                    </div>

                    {/* Scale Type moved next to Root Note */}

                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Root Color
                      </label>
                      <input
                        type="color"
                        value={rootColor}
                        onChange={(e) => setRootColor(e.target.value)}
                        className={`h-10 w-16 rounded border ${darkMode ? 'border-slate-600 bg-slate-800' : 'border-slate-300 bg-white'}`}
                        aria-label="Pick root note color"
                      />
                    </div>

                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Note Color
                      </label>
                      <input
                        type="color"
                        value={noteColor}
                        onChange={(e) => setNoteColor(e.target.value)}
                        className={`h-10 w-16 rounded border ${darkMode ? 'border-slate-600 bg-slate-800' : 'border-slate-300 bg-white'}`}
                        aria-label="Pick scale note color"
                      />
                    </div>

                    <button
                      onClick={() => setShowDegrees(!showDegrees)}
                      className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                        darkMode
                          ? 'bg-indigo-600 hover:bg-indigo-700 text-white'
                          : 'bg-indigo-500 hover:bg-indigo-600 text-white'
                      }`}
                    >
                      {showDegrees ? 'Show Notes' : 'Show Degrees'}
                    </button>

                    <div className="flex flex-col gap-1">
                      <label className={`text-xs ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Frets
                      </label>
                      <div className="flex items-center gap-2">
                        <input
                          type="number"
                          min="1"
                          max="21"
                          value={startFret}
                          onChange={(e) => {
                            const val = Math.max(1, Math.min(20, parseInt(e.target.value) || 1));
                            setStartFret(val);
                            if (val >= endFret) setEndFret(Math.min(21, val + 1));
                          }}
                          className={`w-16 px-2 py-1 text-sm rounded ${
                            darkMode 
                              ? 'bg-slate-800 text-white border-slate-600' 
                              : 'bg-white text-slate-900 border-slate-300'
                          } border`}
                        />
                        <span className={`text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>-</span>
                        <input
                          type="number"
                          min="1"
                          max="21"
                          value={endFret}
                          onChange={(e) => {
                            const val = Math.max(2, Math.min(21, parseInt(e.target.value) || 21));
                            setEndFret(val);
                            if (val <= startFret) setStartFret(Math.max(1, val - 1));
                          }}
                          className={`w-16 px-2 py-1 text-sm rounded ${
                            darkMode 
                              ? 'bg-slate-800 text-white border-slate-600' 
                              : 'bg-white text-slate-900 border-slate-300'
                          } border`}
                        />
                        <button
                          onClick={() => {
                            setStartFret(1);
                            setEndFret(21);
                          }}
                          className={`px-2 py-1 text-xs rounded font-medium transition-colors ${
                            darkMode
                              ? 'bg-slate-700 hover:bg-slate-600 text-white'
                              : 'bg-slate-300 hover:bg-slate-400 text-slate-900'
                          }`}
                          title="Reset to all frets"
                        >
                          Reset
                        </button>
                      </div>
                    </div>
                  </div>
                )}
                    </div>

                {(page === 'Explorer' || page === 'FretBoard') && (
                  <div className={`mt-3 text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>
                    Current Scale: <span className="font-semibold">{rootNote} {scaleNames[scaleType]}</span>
                  </div>
                )}
              </div>
            </div>

            {/* Sidebar Overlay */}
            {isSidebarOpen && (
              <div
                className="fixed inset-0 bg-black/50 z-40"
                onClick={() => setIsSidebarOpen(false)}
              />
            )}

            {/* Sidebar Panel */}
            <div
              className={`fixed top-0 left-0 h-full w-64 z-50 transform transition-transform duration-300 ${
                isSidebarOpen ? 'translate-x-0' : '-translate-x-full'
              } ${darkMode ? 'bg-[#1c1c1c] border-r border-[#2c2c2c] text-white' : 'bg-white border-r border-gray-200 text-slate-900'}`}
            >
              <div className="p-4 flex items-center justify-between border-b border-white/5">
                <div className="font-semibold">Menu</div>
                    <button
                  onClick={() => setIsSidebarOpen(false)}
                  className={`h-8 w-8 grid place-items-center rounded ${darkMode ? 'hover:bg-slate-800' : 'hover:bg-slate-100'}`}
                  title="Close"
                >
                  ‚úï
                </button>
              </div>
              <nav className="p-2">
                {[
                  { key: 'Home', label: 'Home' },
                  { key: 'FretBoard', label: 'Fretboard' },
                  { key: 'Tuner', label: 'Tuner' },
                  { key: 'About', label: 'About' },
                ].map(item => (
                  <button
                    key={item.key}
                    onClick={() => { setPage(item.key); setIsSidebarOpen(false); }}
                    className={`w-full text-left px-3 py-2 rounded mb-1 font-medium transition-colors ${
                      page === item.key
                        ? 'bg-indigo-600 text-white'
                        : darkMode
                        ? 'hover:bg-slate-800 text-slate-200'
                        : 'hover:bg-slate-100 text-slate-800'
                    }`}
                  >
                    {item.label}
                    </button>
                ))}
              </nav>
                </div>

            {/* Main Content */}
            {page === 'Home' && (
              <div className="container mx-auto px-4 py-12">
                <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-3xl font-semibold mb-3`}>Welcome to the FretLab</div>
                <div className={`${darkMode ? 'text-slate-300' : 'text-slate-700'} mb-6`}>
                  Hello, my younglings. Friendly reminder to practice your scales and chords.
                </div>
                {/* image removed from Home */}
                <div className="flex gap-3 mt-6">
                  <button onClick={() => setPage('FretBoard')} className={`${darkMode ? 'bg-indigo-600 hover:bg-indigo-700 text-white' : 'bg-indigo-500 hover:bg-indigo-600 text-white'} px-4 py-2 rounded-lg font-medium`}>
                    Open Fretboard
                  </button>
                  <button onClick={() => setPage('Tuner')} className={`${darkMode ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-slate-300 hover:bg-slate-400 text-slate-900'} px-4 py-2 rounded-lg font-medium`}>
                    Open Tuner
                  </button>
              </div>
            </div>
            )}

            {(page === 'Explorer' || page === 'FretBoard') && (
            <div className="w-full px-2 py-8 flex gap-1">
              {/* Draw Controls Sidebar */}
              <div className={`${darkMode ? 'bg-[#1c1c1c]' : 'bg-white'} rounded-lg p-2 h-fit w-24`}>
                <div className="flex flex-col gap-2">
                  <button
                    onClick={() => setDrawingMode(drawingMode === 'draw' ? null : 'draw')}
                    className={`px-2 py-2 rounded-lg font-medium transition-colors text-sm ${
                      drawingMode === 'draw'
                        ? 'bg-blue-600 text-white'
                        : darkMode
                        ? 'bg-slate-800 hover:bg-slate-700 text-white'
                        : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                    }`}
                    title="Draw"
                  >
                    ‚úèÔ∏èDraw
                  </button>

                  <button
                    onClick={() => setDrawingMode(drawingMode === 'erase' ? null : 'erase')}
                    className={`px-2 py-2 rounded-lg font-medium transition-colors text-sm ${
                      drawingMode === 'erase'
                        ? 'bg-red-600 text-white'
                        : darkMode
                        ? 'bg-slate-800 hover:bg-slate-700 text-white'
                        : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                    }`}
                    title="Erase"
                  >
                    üßπErase
                  </button>

                  <button
                    onClick={() => setDrawings({})}
                    className={`px-2 py-2 rounded-lg font-medium transition-colors text-sm ${
                      darkMode
                        ? 'bg-slate-800 hover:bg-slate-700 text-white'
                        : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                    }`}
                    title="Clear all"
                  >
                    üîÑClear
                  </button>
                </div>
                <div className={`mt-2 p-2 rounded ${darkMode ? 'bg-[#111]' : 'bg-slate-100'} overflow-hidden`}>
                  <div className={`text-xs mb-2 ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>Metronome</div>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      min="20"
                      max="300"
                      step="1"
                      value={bpm}
                      inputMode="numeric"
                      onChange={(e)=> setBpm(Math.max(20, Math.min(300, parseInt(e.target.value) || 0)))}
                      onBlur={(e)=> setBpm(Math.max(20, Math.min(300, parseInt(e.target.value) || 100)))}
                      className={`w-[72px] px-2 py-1 text-xs rounded ${darkMode ? 'bg-slate-800 text-white border-slate-600' : 'bg-white text-slate-900 border-slate-300'} border`}
                    />
                    {/* BPM label removed */}
                  </div>
                  {/* Slider removed per request */}
                  <div className="flex gap-2 mt-2">
                    {!isMetronomeOn ? (
                      <button onClick={startMetronome} className={`${darkMode ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'} px-2 py-1 rounded text-xs font-medium w-full`}>Start</button>
                    ) : (
                      <button onClick={stopMetronome} className={`${darkMode ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-red-600 hover:bg-red-700 text-white'} px-2 py-1 rounded text-xs font-medium w-full`}>Stop</button>
                    )}
                  </div>
                </div>
              </div>

              <div className="overflow-x-auto flex-1">
                <div className="block w-full">
                  <div className={`${darkMode ? 'bg-[#2a2a2a]' : 'bg-gray-200'} rounded-lg p-8 relative`}>
                    <div className="flex mb-2">
                      <div className="w-16"></div>
                      <div className="flex flex-1">
                      {[...Array(21)].map((_, fret) => {
                        const fretNum = fret + 1;
                        if (fretNum < startFret || fretNum > endFret) return null;
                        return (
                          <div
                            key={fret}
                              className={`text-center text-xs font-semibold ${
                              darkMode ? 'text-slate-400' : 'text-slate-600'
                            }`}
                              style={{ width: `${100 / visibleFretCount}%` }}
                          >
                            {fretNum}
                          </div>
                        );
                      })}
                      </div>
                    </div>

                    {strings.map((string, stringIndex) => (
                      <div key={stringIndex} className="flex items-center mb-1">
                        <div
                          className={`w-14 text-center font-bold ${
                            darkMode ? 'text-slate-200' : 'text-slate-700'
                          }`}
                        >
                          {string.name}
                        </div>

                        <div className="flex flex-1 relative">
                          <div
                            className={`absolute left-0 right-0 top-1/2 transform -translate-y-1/2 ${
                              darkMode ? 'bg-slate-600' : 'bg-slate-400'
                            }`}
                            style={{ height: `${2 + stringIndex * 0.3}px` }}
                          ></div>

                          {[...Array(21)].map((_, fret) => {
                            const fretNum = fret + 1; // Display fret number starting from 1
                            const noteIndex = getNoteAtFret(string.openNote, fretNum);
                            const inScale = isNoteInScale(noteIndex);
                            const isRoot = isRootNote(noteIndex);
                            const degree = getScaleDegree(noteIndex);
                            const isHovered = hoveredNote === `${stringIndex}-${fretNum}`;
                            
                            // Only show frets in the selected range
                            if (fretNum < startFret || fretNum > endFret) return null;

                            const drawKey = `${stringIndex}-${fretNum}`;
                            const isDrawn = drawings[drawKey];
                            
                            return (
                            <div
                              key={fret}
                              className="h-14 flex items-center justify-center relative rounded-lg"
                                style={{ width: `${100 / visibleFretCount}%` }}
                                onMouseEnter={() => setHoveredNote(drawKey)}
                                onMouseLeave={() => setHoveredNote(null)}
                                onClick={() => {
                                  if (drawingMode === 'draw') {
                                    setDrawings({...drawings, [drawKey]: true});
                                  } else if (drawingMode === 'erase') {
                                    const newDrawings = {...drawings};
                                    delete newDrawings[drawKey];
                                    setDrawings(newDrawings);
                                  }
                                }}
                              >
                                {fret > 0 && (
                                  <div
                                    className={`absolute left-0 top-0 bottom-0 w-0.5 ${
                                      darkMode ? 'bg-slate-700' : 'bg-slate-300'
                                    }`}
                                  ></div>
                                )}

                                {/* Drawn note overlay */}
                                {isDrawn && (
                                  <div className="absolute inset-0 border-4 border-yellow-400 rounded-lg pointer-events-none z-20" />
                                )}

                                {(() => {
                                  // First check if chord is selected
                                  if (selectedChord) {
                                    const shouldShow = isToneInChord(noteIndex);
                                    if (!shouldShow) return null;
                                  } else if (!inScale) return null;
                                  
                                  const isChordRootNote = isChordRoot(noteIndex);
                                  const isChordThirdNote = isChordThird(noteIndex);
                                  const isScaleRootNote = isRootNote(noteIndex);
                                  
                                  let bgColor;
                                  if (selectedChord) {
                                    if (isChordRootNote) bgColor = rootColor;
                                    else if (isChordThirdNote) bgColor = thirdColor;
                                    else bgColor = noteColor;
                                  } else {
                                    bgColor = isScaleRootNote ? rootColor : noteColor;
                                  }
                                  
                                  return (
                                    <div
                                      className={`relative z-10 w-10 h-10 rounded-full flex items-center justify-center text-xs font-bold cursor-default transition-all ${isHovered ? 'scale-110 shadow-lg' : 'shadow-md'}`}
                                      style={{ 
                                        backgroundColor: bgColor,
                                        color: '#ffffff'
                                      }}
                                    >
                                      {showDegrees ? formatDegree(degree, noteIndex) : notes[noteIndex]}
                                    </div>
                                  );
                                })()}

                                {stringIndex === 2 && (fretNum === 3 || fretNum === 5 || fretNum === 7 || fretNum === 9 || fretNum === 15 || fretNum === 17 || fretNum === 19 || fretNum === 21) && (
                                  <div
                                    className={`absolute w-2 h-2 rounded-full ${
                                      darkMode ? 'bg-slate-600' : 'bg-slate-400'
                                    } opacity-50`}
                                    style={{ top: '50%', transform: 'translateY(-50%)' }}
                                  ></div>
                                )}
                                {stringIndex === 3 && fretNum === 12 && (
                                  <div
                                    className={`absolute w-2 h-2 rounded-full ${
                                      darkMode ? 'bg-slate-600' : 'bg-slate-400'
                                    } opacity-50`}
                                    style={{ top: '30%', transform: 'translateY(-50%)' }}
                                  ></div>
                                )}
                                {stringIndex === 2 && fretNum === 12 && (
                                  <div
                                    className={`absolute w-2 h-2 rounded-full ${
                                      darkMode ? 'bg-slate-600' : 'bg-slate-400'
                                    } opacity-50`}
                                    style={{ top: '70%', transform: 'translateY(-50%)' }}
                                  ></div>
                                )}
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
            )}

            {page === 'Tuner' && (
              <div className="container mx-auto px-4 py-12">
                <div className="flex items-center justify-between mb-6">
                  <div className="flex items-center gap-3">
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-2xl font-semibold`}>Guitar Tuner</div>
                    <label className={`flex items-center gap-2 text-sm ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>
                      <input type="checkbox" checked={autoDetectString} onChange={(e)=> setAutoDetectString(e.target.checked)} />
                      Auto string detect
                    </label>
                  </div>
                  <div className="flex gap-2">
                    {!isTunerOn ? (
                      <button onClick={startTuner} className={`${darkMode ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'} px-4 py-2 rounded-lg font-medium`}>
                        Start
                      </button>
                    ) : (
                      <button onClick={stopTuner} className={`${darkMode ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-red-600 hover:bg-red-700 text-white'} px-4 py-2 rounded-lg font-medium`}>
                        Stop
                      </button>
                    )}
                  </div>
                </div>

                {tunerError && (
                  <div className={`${darkMode ? 'bg-red-900/40 text-red-200 border-red-700' : 'bg-red-100 text-red-800 border-red-300'} border rounded p-3 mb-4`}>
                    Microphone error: {tunerError}
                  </div>
                )}

                <div className={`${darkMode ? 'bg-[#1c1c1c]' : 'bg-white'} rounded-xl border ${darkMode ? 'border-[#2c2c2c]' : 'border-gray-200'} p-6 grid grid-cols-1 md:grid-cols-3 gap-6`}>
                  <div className="md:col-span-2 flex flex-col items-center justify-center">
                    <div className="relative w-64 h-32">
                      <div className="absolute inset-0 flex items-end justify-center">
                        <div className={`${darkMode ? 'text-slate-400' : 'text-slate-600'} text-xs`}>-50¬¢</div>
                        <div className="flex-1" />
                        <div className={`${darkMode ? 'text-slate-400' : 'text-slate-600'} text-xs`}>+50¬¢</div>
                      </div>
                      {/* Green in-tune zone (¬±5¬¢) */}
                      <div className="absolute left-1/2 bottom-0 -translate-x-1/2 w-8 h-24 bg-green-500/25 rounded" />
                      <div className="absolute left-1/2 bottom-0 -translate-x-1/2 w-1 h-24 bg-indigo-600 origin-bottom rounded"
                        style={{ transform: `translateX(-50%) rotate(${(tunerCents / 50) * 45}deg)` }}
                      />
                      <div className="absolute left-0 right-0 bottom-0 h-1.5 ${darkMode ? 'bg-slate-700' : 'bg-slate-300'} rounded" />
                    </div>
                    <div className="mt-6 text-center">
                      <div className={`${darkMode ? 'text-slate-300' : 'text-slate-700'} text-sm`}>Detected</div>
                      <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-5xl font-bold leading-tight`}>{tunerNote}</div>
                      <div className={`${darkMode ? 'text-slate-300' : 'text-slate-700'} text-sm mt-1`}>{tunerFreq ? tunerFreq.toFixed(1) + ' Hz' : '--'}</div>
                      <div className={`mt-2 text-sm font-medium ${Math.abs(tunerCents) <= 5 ? 'text-green-500' : 'text-amber-500'}`}>
                        {Math.abs(tunerCents) <= 5 ? 'In tune' : tunerCents < 0 ? `${Math.abs(tunerCents)}¬¢ flat` : `${tunerCents}¬¢ sharp`}
                      </div>
                      {/* Target string indicator with hold progress */}
                      <div className="mt-4 flex flex-col items-center gap-1">
                        <div className={`${darkMode ? 'text-slate-200' : 'text-slate-900'} text-sm font-semibold`}>
                          Target: {tuningPresets[tuning][selectedString]}
                        </div>
                        <div className="w-40 h-2 rounded-full overflow-hidden border border-black/10">
                          {(() => {
                            const start = stringHoldStart;
                            const progress = stringConfirmed ? 1 : (start ? Math.min(1, (performance.now() - start) / 3000) : 0);
                            const barColor = stringConfirmed ? 'bg-green-500' : 'bg-amber-500';
                            return <div className={`${barColor} h-full`} style={{ width: `${progress * 100}%` }} />;
                          })()}
                        </div>
                      </div>
                    </div>
                  </div>
                  {/* Right column: Headstock + Tuning */}
                  <div className="space-y-3">
                    <div className={`text-sm ${darkMode ? 'text-slate-200' : 'text-slate-900'} font-semibold`}>Tuning</div>
                    <select
                      value={tuning}
                      onChange={(e)=> setTuning(e.target.value)}
                      className={`w-full px-3 h-9 text-sm rounded-lg ${darkMode ? 'bg-slate-800 text-white border-slate-600' : 'bg-white text-slate-900 border-slate-300'} border focus:outline-none`}
                    >
                      <option value="standard">Standard (E A D G B E)</option>
                      <option value="dropD">Drop D (D A D G B E)</option>
                      <option value="halfStepDown">Half-step Down (D# G# C# F# A# D#)</option>
                    </select>

                    <div className={`mt-2 ${darkMode ? 'bg-[#0f0f0f] border-[#2c2c2c]' : 'bg-slate-100 border-slate-300'} border rounded-lg p-3`}>
                      <div className={`text-xs mb-2 ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>Headstock</div>
                      {/* Acoustic-style headstock: 3+3 tuners */}
                      <div className="relative w-72 h-44 mx-auto">
                        {/* Wood headstock body */}
                        <div className={`absolute left-1/2 -translate-x-1/2 top-2 bottom-2 w-20 rounded-[24px] ${darkMode ? 'bg-[#2a1b10]' : 'bg-amber-800'} shadow-inner`} />
                        {/* Nut */}
                        <div className={`${darkMode ? 'bg-slate-300' : 'bg-slate-200'} absolute left-1/2 -translate-x-1/2 bottom-2 h-1 w-24 rounded`} />

                        {(() => {
                          // 3 pegs per side (left/right), bottom to top is low->high
                          const positions = [
                            { idx: 0, side: 'left', top: '76%' },
                            { idx: 1, side: 'left', top: '50%' },
                            { idx: 2, side: 'left', top: '24%' },
                            { idx: 3, side: 'right', top: '24%' }, // G (top)
                            { idx: 4, side: 'right', top: '50%' }, // B (middle)
                            { idx: 5, side: 'right', top: '76%' }, // E (bottom)
                          ];

                          return positions.map((p) => {
                            const open = tuningPresets[tuning][p.idx];
                            const isSelected = p.idx === selectedString;
                            const pillClass = isSelected
                              ? (stringConfirmed
                                  ? 'bg-green-600 text-white border-green-600'
                                  : 'bg-amber-500 text-white border-amber-500')
                              : `${darkMode ? 'bg-slate-800 text-white border-slate-600' : 'bg-white text-slate-900 border-slate-300'}`;
                            const pegSideClass = p.side === 'left' ? 'left-3' : 'right-3';
                            const labelSideClass = p.side === 'left' ? 'left-12' : 'right-12';
                            const stringAnchorClass = p.side === 'left' ? 'left-[88px]' : 'right-[88px]';
                            return (
                              <div key={p.idx} className="absolute" style={{ top: p.top, left: 0, right: 0 }}>
                                {/* String segment to nut */}
                                <div className={`absolute ${stringAnchorClass} h-0.5 ${darkMode ? 'bg-slate-500' : 'bg-slate-400'} w-16`} />
                                {/* Peg */}
                                <div className={`absolute ${pegSideClass} -translate-y-1/2`}>
                                  <div className={`${darkMode ? 'bg-zinc-300' : 'bg-zinc-200'} w-4 h-4 rounded-full shadow`} />
                                </div>
                                {/* Clickable note label */}
                                <button
                                  type="button"
                                  className={`absolute ${labelSideClass} -translate-y-1/2 px-2 py-0.5 text-xs rounded-full border ${pillClass}`}
                                  onClick={() => {
                                    setSelectedString(p.idx);
                                    playStringSound(p.idx);
                                  }}
                                >
                                  {open}
                                </button>
                              </div>
                            );
                          });
                        })()}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            

            {page === 'About' && (
              <div className="container mx-auto px-4 py-12">
                <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-2xl font-semibold mb-4`}>About</div>
              </div>
            )}

            {/* Chords in Scale - hidden on Home, Tuner, and About */}
            {page !== 'Home' && page !== 'Tuner' && page !== 'About' && (
            <div className="container mx-auto px-4 py-8">
              <div className="mt-6">
                <div className="flex items-center justify-between mb-3">
                  <h3 className={`${darkMode ? 'text-white' : 'text-slate-900'} font-semibold`}>
                    Chords in Scale ({chordType})
                  </h3>
                  {selectedChord && (
                    <button
                      onClick={() => setSelectedChord(null)}
                      className={`px-3 py-1.5 text-sm rounded-lg font-medium transition-colors ${
                        darkMode
                          ? 'bg-slate-700 hover:bg-slate-600 text-white'
                          : 'bg-slate-300 hover:bg-slate-400 text-slate-900'
                      }`}
                    >
                      Clear Selection
                    </button>
                  )}
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                  {buildDiatonicChords.map((ch) => (
                    <div 
                      key={`${ch.degree}-${ch.name}`} 
                      className={`${darkMode ? 'bg-[#2a2a2a]' : 'bg-gray-200'} rounded-lg p-3 cursor-pointer transition-all hover:scale-105 ${
                        selectedChord && selectedChord.name === ch.name ? 'ring-2 ring-yellow-400' : ''
                      }`}
                      onClick={() => setSelectedChord(ch)}
                    >
                      <div className="flex items-center justify-between">
                        <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium`}>
                          {ch.degree}. {ch.name}
                        </div>
                        <div className="flex -space-x-1">
                          {ch.pcs.map((pc, idx) => (
                            <div key={idx} className="w-6 h-6 rounded-full border border-black/10 flex items-center justify-center text-[10px] font-bold"
                              style={{ backgroundColor: idx===0 ? rootColor : (idx===1 ? thirdColor : noteColor), color: '#fff' }}
                            >
                              {notes[pc]}
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
            )}
          </div>
        );
      };

      window.GuitarScaleExplorer = GuitarScaleExplorer;
    </script>

    <!-- Mount the component with error handling -->
    <script type="text/babel">
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false, error: null };
        }
        static getDerivedStateFromError(error) {
          return { hasError: true, error };
        }
        componentDidCatch(error, info) {
          console.error('Render error:', error, info);
        }
        render() {
          if (this.state.hasError) {
            return (
              <div className="min-h-screen flex items-center justify-center bg-red-50 p-6">
                <div className="max-w-lg w-full bg-white shadow rounded-lg p-6 border border-red-200">
                  <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
                  <p className="text-sm text-red-600">{String(this.state.error)}</p>
                  <button
                    className="mt-4 px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700"
                    onClick={() => window.location.reload()}
                  >
                    Reload
                  </button>
                </div>
              </div>
            );
          }
          return this.props.children;
        }
      }

      function mountApp() {
        try {
          if (!window.GuitarScaleExplorer) {
            throw new Error('Component not loaded yet.');
          }
          const container = document.getElementById('root');
          if (!container) {
            throw new Error('Root container not found.');
          }
          const root = ReactDOM.createRoot(container);
          root.render(
            <ErrorBoundary>
              <GuitarScaleExplorer />
            </ErrorBoundary>
          );
        } catch (e) {
          console.error(e);
          const container = document.getElementById('root');
          if (container) {
            container.innerHTML = `
              <div style="min-height:100vh;display:flex;align-items:center;justify-content:center;background:#fff1f2;padding:24px;">
                <div style="max-width:640px;width:100%;background:#ffffff;border:1px solid #fecaca;border-radius:12px;padding:16px;font-family:ui-sans-serif,system-ui;">
                  <div style="font-weight:600;color:#b91c1c;margin-bottom:8px;">Failed to load the app</div>
                  <div style="color:#991b1b;font-size:14px;">${String(e)}</div>
                </div>
              </div>`;
          }
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', mountApp);
      } else {
        mountApp();
      }
    </script>
  </body>
  </html>


