<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FretLab - Guitar Scale & Chord Explorer</title>
    <meta name="description" content="Interactive guitar scale and chord explorer with fretboard visualization">
    <!-- Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      :root { --font-sans: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji'; }
      html, body { font-family: var(--font-sans); }
    </style>
  </head>
  <body class="antialiased">
    <div id="root"></div>

    <!-- React and ReactDOM via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for in-browser JSX transform -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Your component code (inlined for file:// compatibility) -->
    <script type="text/babel" data-presets="env,react">
      /* global React */
      const { useState, useMemo } = React;

      const Sun = ({ size = 20 }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="4"></circle>
          <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"></path>
        </svg>
      );

      const Moon = ({ size = 20 }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width={size}
          height={size}
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
      );

      const GuitarScaleExplorer = () => {
        const [rootNote, setRootNote] = useState('C');
        const [scaleType, setScaleType] = useState('major');
        const [showDegrees, setShowDegrees] = useState(false);
        const [darkMode, setDarkMode] = useState(true);
        const [hoveredNote, setHoveredNote] = useState(null);
        const [rootColor, setRootColor] = useState('#ef4444'); // red-500
        const [noteColor, setNoteColor] = useState('#3b82f6'); // blue-500
        const [thirdColor, setThirdColor] = useState('#10b981'); // green-500
        const [chordType, setChordType] = useState('triads'); // triads | sevenths
        const [selectedChord, setSelectedChord] = useState(null);
        const [startFret, setStartFret] = useState(1); // First fret to display
        const [endFret, setEndFret] = useState(21); // Last fret to display
        const [drawingMode, setDrawingMode] = useState(null); // 'draw' | 'erase' | null
        const [drawings, setDrawings] = useState({}); // { 'string-fret': true }
        const [isSidebarOpen, setIsSidebarOpen] = useState(false);
        const [page, setPage] = useState('Home'); // Home | Explorer | FretBoard | Tuner | About | Jam Mode
        const imgVersion = useMemo(() => Date.now(), []);

        // --- Metronome ---
        const [bpm, setBpm] = useState(100);
        const [isMetronomeOn, setIsMetronomeOn] = useState(false);
        const [isMetronomeEnabled, setIsMetronomeEnabled] = useState(false); // Jam Mode enable toggle
        const metroRef = React.useRef({ audioCtx: null, intervalId: null });
        const click = () => {
          try {
            const ctx = metroRef.current.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            metroRef.current.audioCtx = ctx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(1000, ctx.currentTime);
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.001);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.1);
          } catch (e) {
            /* no-op */
          }
        };
        const startMetronome = () => {
          if (isMetronomeOn) return;
          const ms = Math.max(60_000 / Math.max(20, Math.min(300, bpm)), 50);
          click();
          metroRef.current.intervalId = setInterval(click, ms);
          setIsMetronomeOn(true);
        };
        const stopMetronome = () => {
          if (metroRef.current.intervalId) clearInterval(metroRef.current.intervalId);
          metroRef.current.intervalId = null;
          setIsMetronomeOn(false);
        };
        React.useEffect(() => {
          if (!isMetronomeOn) return;
          if (metroRef.current.intervalId) {
            clearInterval(metroRef.current.intervalId);
            metroRef.current.intervalId = null;
          }
          const ms = Math.max(60_000 / Math.max(20, Math.min(300, bpm)), 50);
          metroRef.current.intervalId = setInterval(click, ms);
          return () => {
            if (metroRef.current.intervalId) clearInterval(metroRef.current.intervalId);
          };
        }, [bpm, isMetronomeOn]);
        // home image state removed (not needed)

        // --- Tuner state ---
        const [isTunerOn, setIsTunerOn] = useState(false);
        const [tunerFreq, setTunerFreq] = useState(0);
        const [tunerNote, setTunerNote] = useState('-');
        const [tunerCents, setTunerCents] = useState(0);
        const [tunerError, setTunerError] = useState(null);
        const tunerRef = React.useRef({
          audioCtx: null,
          analyser: null,
          source: null,
          stream: null,
          rafId: null,
          buf: null,
        });

        // Chromatic note names
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Tuning presets (headstock display, low->high)
        const [tuning, setTuning] = useState('standard'); // standard | dropD | halfStepDown
        const tuningPresets = {
          standard: ['E', 'A', 'D', 'G', 'B', 'E'],
          dropD: ['D', 'A', 'D', 'G', 'B', 'E'],
          halfStepDown: ['D#', 'G#', 'C#', 'F#', 'A#', 'D#'],
        };

        // Headstock selection and confirmation logic
        const [selectedString, setSelectedString] = useState(0); // 0 = lowest string in preset list
        const [stringHoldStart, setStringHoldStart] = useState(null);
        const [stringConfirmed, setStringConfirmed] = useState(false);
        const [autoDetectString, setAutoDetectString] = useState(true);

        // --- Jam Mode ---
        const [isRecording, setIsRecording] = useState(false);
        const [recordedAudio, setRecordedAudio] = useState(null);
        const [isPlaying, setIsPlaying] = useState(false);
        const [isLooping, setIsLooping] = useState(false);
        const [selectedProgression, setSelectedProgression] = useState(null); // index into chordProgressions
        const [audioDuration, setAudioDuration] = useState(0);
        const [cropStart, setCropStart] = useState(0);
        const [cropEnd, setCropEnd] = useState(0);
        const [isCropping, setIsCropping] = useState(false);
        const [originalAudio, setOriginalAudio] = useState(null); // Store original before trimming for reset
        const [undoStack, setUndoStack] = useState([]); // Stack of states for undo: [{audio, audioBuffer, cropStart, cropEnd, duration}]
        const [selectedKey, setSelectedKey] = useState('C');
        const [countdown, setCountdown] = useState(null);
        const [isCountdownActive, setIsCountdownActive] = useState(false);
        const [showCropUI, setShowCropUI] = useState(false);
        const [savedLoops, setSavedLoops] = useState([]); // [{id, name, createdAt, bpm, key, progressionName}]
        const [playbackTime, setPlaybackTime] = useState(0); // Current playback position for waveform indicator
        const idbRef = React.useRef({ db: null });
        const jamModeRef = React.useRef({
          mediaRecorder: null,
          audioChunks: [],
          audioContext: null,
          audioBuffer: null,
          sourceNode: null,
          loopTimeout: null,
          shouldLoop: false,
          audioElement: null,
          countdownInterval: null,
          metronomeStartedByRecording: false,
          countdownTimeouts: [],
        });

        const waveformRef = React.useRef({
          canvas: null,
          ctx: null,
          dragging: null, // 'start' | 'end' | 'move' | null
          dragOffset: 0, // Offset for moving entire selection
          pixelsPerSecond: 100,
          currentCropStart: null, // Current drag value for start
          currentCropEnd: null, // Current drag value for end
        });

        const musicalKeys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Roman numeral progressions; case indicates chord quality (upper = major, lower = minor), 'vii°' diminished
        const chordProgressions = [
          { name: 'I-V-vi-IV (Pop)', romans: ['I', 'V', 'vi', 'IV'] },
          { name: 'I-vi-IV-V (50s)', romans: ['I', 'vi', 'IV', 'V'] },
          { name: 'vi-IV-I-V', romans: ['vi', 'IV', 'I', 'V'] },
          { name: 'I-V-IV-I', romans: ['I', 'V', 'IV', 'I'] },
          { name: 'ii-V-I', romans: ['ii', 'V', 'I'] },
          { name: 'Custom', romans: [] },
        ];

        const scaleNotesMajor = (root) => {
          const all = musicalKeys; // enharmonic simplification
          const idx = all.indexOf(root);
          if (idx < 0) return [];
          const majorSteps = [0, 2, 4, 5, 7, 9, 11];
          return majorSteps.map(semi => all[(idx + Math.round(semi/1)) % all.length]);
        };

        const romanToChordInKey = (key, roman) => {
          const scale = scaleNotesMajor(key);
          if (!scale.length) return '';
          const map = { 'I':0,'ii':1,'II':1,'iii':2,'III':2,'IV':3,'iv':3,'V':4,'v':4,'vi':5,'VI':5,'vii':6,'VII':6 };
          const deg = map[roman.replace('°','')] ?? 0;
          const note = scale[deg];
          const isDim = roman.includes('vii') || roman.includes('°');
          const isMinor = roman === roman.toLowerCase() && !isDim;
          if (isDim) return note + 'dim';
          if (isMinor) return note + 'm';
          return note;
        };

        const chordsForProgression = (key, romans) => romans.map(r => romanToChordInKey(key, r));

        const playCountdownClick = () => {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, ctx.currentTime);
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.001);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
          } catch (e) {
            /* no-op */
          }
        };

        const startCountdown = async () => {
          // Clear any prior countdown timers
          if (jamModeRef.current.countdownInterval) {
            clearInterval(jamModeRef.current.countdownInterval);
            jamModeRef.current.countdownInterval = null;
          }
          if (jamModeRef.current.countdownTimeouts && jamModeRef.current.countdownTimeouts.length) {
            jamModeRef.current.countdownTimeouts.forEach(t => clearTimeout(t));
            jamModeRef.current.countdownTimeouts = [];
          }

          // Prepare mic and recorder before countdown to avoid permission/creation latency
          const ok = await prepareRecorder();
          if (!ok) return;

          const bpmValue = Math.max(20, Math.min(300, bpm));
          const beatInterval = 60000 / bpmValue; // ms per beat
          // Compensate for MediaRecorder.start() latency (~50-100ms)
          const recordingOffset = Math.min(80, beatInterval * 0.1); // Cap at 80ms or 10% of beat interval

          setIsCountdownActive(true);
          setCountdown(1); // show big 1
          playCountdownClick(); // beat 1 click

          const timeouts = [];
          // Schedule beats 2, 3, 4
          [2,3,4].forEach((num, idx) => {
            timeouts.push(setTimeout(() => {
              setCountdown(num);
              playCountdownClick();
            }, (idx + 1) * beatInterval));
          });
          // Start recording slightly before beat 5 to compensate for MediaRecorder.start() latency
          // This ensures audio actually starts capturing at the right time
          timeouts.push(setTimeout(() => {
            setIsCountdownActive(false);
            setCountdown(null);
            startPreparedRecording();
          }, 4 * beatInterval - recordingOffset));

          jamModeRef.current.countdownTimeouts = timeouts;
        };

        // Prepare MediaRecorder before countdown to eliminate start latency
        const prepareRecorder = async () => {
          try {
            // If currently recording, don't re-prepare
            if (jamModeRef.current.mediaRecorder && jamModeRef.current.mediaRecorder.state === 'recording') return true;
            // Note: We can't reuse MediaRecorder after stream is closed, so we always create new one
            // But we prepare it early to minimize latency

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mediaRecorder = new MediaRecorder(stream);
            const audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                jamModeRef.current.audioChunks.push(event.data);
              }
            };

            const streamRef = stream; // Capture stream for onstop
            mediaRecorder.onstop = () => {
              const audioBlob = new Blob(jamModeRef.current.audioChunks, { type: 'audio/webm' });
              setRecordedAudio(audioBlob);
              setOriginalAudio(audioBlob); // Store as original for reset
              setIsRecording(false);
              // Reset trim to full audio for new recording, but keep edit UI open
              jamModeRef.current.audioBuffer = null; // Force reload waveform
              setCropStart(0);
              // Clear undo history for new recording
              setUndoStack([]);
              // Don't reset originalAudio - keep it so user can reset if needed
              // stop all tracks
              streamRef.getTracks().forEach(track => track.stop());
              
              // Load audio to get duration
              const audio = new Audio(URL.createObjectURL(audioBlob));
              audio.addEventListener('loadedmetadata', () => {
                setAudioDuration(audio.duration);
                setCropEnd(audio.duration);
                audio.remove();
              });
            };

            jamModeRef.current.mediaRecorder = mediaRecorder;
            jamModeRef.current.audioChunks = audioChunks;
            return true;
          } catch (e) {
            console.error('Error preparing recorder:', e);
            alert('Error accessing microphone. Please allow microphone access.');
            setIsCountdownActive(false);
            setCountdown(null);
            return false;
          }
        };

        const startPreparedRecording = async () => {
          let mr = jamModeRef.current.mediaRecorder;
          if (!mr || mr.state !== 'inactive') {
            const ok = await prepareRecorder();
            if (!ok) return;
            mr = jamModeRef.current.mediaRecorder;
          }
          // Reset chunks array for new recording
          if (mr && mr.state === 'inactive') {
            jamModeRef.current.audioChunks = [];
          }
          try {
            mr.start();
            setIsRecording(true);
            // Start metronome only if enabled and not already running
            if (isMetronomeEnabled && !isMetronomeOn) {
              startMetronome();
              jamModeRef.current.metronomeStartedByRecording = true;
            }
          } catch (e) {
            console.error('Failed to start MediaRecorder, retrying with fresh recorder:', e);
            // Try once more with a fresh recorder
            jamModeRef.current.mediaRecorder = null;
            const ok = await prepareRecorder();
            if (!ok) return;
            mr = jamModeRef.current.mediaRecorder;
            try {
              mr.start();
              setIsRecording(true);
              if (isMetronomeEnabled && !isMetronomeOn) {
                startMetronome();
                jamModeRef.current.metronomeStartedByRecording = true;
              }
            } catch (err) {
              console.error('Second attempt to start MediaRecorder failed:', err);
            }
          }
        };

        const startRecording = async () => {
          if (isRecording || isCountdownActive) return;
          // Start preparing recorder immediately for minimal latency
          prepareRecorder();
          startCountdown();
        };

        const undoTrim = async () => {
          if (undoStack.length === 0) return;
          
          // Stop any playback
          if (isPlaying) stopPlayback();
          
          // Pop the last state from undo stack
          const stateToRestore = undoStack[undoStack.length - 1];
          setUndoStack(prev => prev.slice(0, -1)); // Remove last item
          
          // Restore the state
          setRecordedAudio(stateToRestore.audio);
          
          // Restore audio buffer if available, otherwise decode
          if (stateToRestore.audioBuffer) {
            jamModeRef.current.audioBuffer = stateToRestore.audioBuffer;
            setAudioDuration(stateToRestore.duration);
            setCropStart(stateToRestore.cropStart);
            setCropEnd(stateToRestore.cropEnd);
            
            // Redraw waveform
            setTimeout(() => drawWaveform(), 50);
          } else {
            // Need to decode the audio
            const audioUrl = URL.createObjectURL(stateToRestore.audio);
            const audio = new Audio(audioUrl);
            audio.addEventListener('loadedmetadata', async () => {
              setAudioDuration(stateToRestore.duration || audio.duration);
              setCropStart(stateToRestore.cropStart || 0);
              setCropEnd(stateToRestore.cropEnd || (stateToRestore.duration || audio.duration));
              audio.remove();
              
              // Reload waveform buffer
              try {
                const resp = await fetch(audioUrl);
                const arr = await resp.arrayBuffer();
                const ac = new (window.AudioContext || window.webkitAudioContext)();
                const decoded = await ac.decodeAudioData(arr);
                jamModeRef.current.audioBuffer = decoded;
                ac.close();
                URL.revokeObjectURL(audioUrl);
                
                // Redraw waveform
                setTimeout(() => drawWaveform(), 50);
              } catch (e) {
                console.error('Failed to reload waveform:', e);
                URL.revokeObjectURL(audioUrl);
              }
            });
          }
        };

        const stopRecording = () => {
          // Cancel countdown if active
          if (isCountdownActive) {
            if (jamModeRef.current.countdownInterval) {
              clearInterval(jamModeRef.current.countdownInterval);
              jamModeRef.current.countdownInterval = null;
            }
            if (jamModeRef.current.countdownTimeouts && jamModeRef.current.countdownTimeouts.length) {
              jamModeRef.current.countdownTimeouts.forEach(t => clearTimeout(t));
              jamModeRef.current.countdownTimeouts = [];
            }
            setIsCountdownActive(false);
            setCountdown(null);
            return;
          }
          
          // Stop actual recording or release prepared stream if any
          const mr = jamModeRef.current.mediaRecorder;
          if (mr) {
            if (mr.state !== 'inactive') {
              mr.stop();
            } else {
              // If prepared but not started, close tracks
              try {
                const tracks = mr.stream ? mr.stream.getTracks() : [];
                tracks.forEach(t => t.stop());
              } catch {}
              jamModeRef.current.mediaRecorder = null;
            }
          }
          if (jamModeRef.current.metronomeStartedByRecording && isMetronomeOn) {
            stopMetronome();
            jamModeRef.current.metronomeStartedByRecording = false;
          }
        };

        const playRecordedAudio = () => {
          if (!recordedAudio) return;
          if (!jamModeRef.current.shouldLoop && isPlaying) return; // Prevent duplicate playback when not looping
          
          jamModeRef.current.shouldLoop = isLooping;
          
          const audioUrl = URL.createObjectURL(recordedAudio);
          const audio = new Audio(audioUrl);
          
          // Update playback time for waveform indicator
          audio.addEventListener('timeupdate', () => {
            setPlaybackTime(audio.currentTime);
          });
          
          audio.onended = () => {
            setPlaybackTime(0); // Reset indicator
            URL.revokeObjectURL(audioUrl);
            if (jamModeRef.current.shouldLoop && jamModeRef.current.sourceNode === audio) {
              // Loop immediately - no delay
              jamModeRef.current.sourceNode = null;
              if (jamModeRef.current.shouldLoop) {
                // Start next loop immediately
                playRecordedAudio();
              } else {
                setIsPlaying(false);
              }
            } else {
              setIsPlaying(false);
              jamModeRef.current.sourceNode = null;
            }
          };
          
          audio.onerror = () => {
            setPlaybackTime(0);
            URL.revokeObjectURL(audioUrl);
            setIsPlaying(false);
            jamModeRef.current.sourceNode = null;
          };
          
          audio.play().catch(e => {
            console.error('Playback error:', e);
            setPlaybackTime(0);
            setIsPlaying(false);
            jamModeRef.current.sourceNode = null;
          });
          
          jamModeRef.current.sourceNode = audio;
          setIsPlaying(true);
        };

        const stopPlayback = () => {
          jamModeRef.current.shouldLoop = false;
          if (jamModeRef.current.loopTimeout) {
            clearTimeout(jamModeRef.current.loopTimeout);
            jamModeRef.current.loopTimeout = null;
          }
          if (jamModeRef.current.sourceNode) {
            jamModeRef.current.sourceNode.pause();
            jamModeRef.current.sourceNode.currentTime = 0;
            jamModeRef.current.sourceNode.onended = null; // Prevent onended from firing
            jamModeRef.current.sourceNode = null;
          }
          setPlaybackTime(0); // Reset indicator
          setIsPlaying(false);
          setIsLooping(false);
        };

        // IndexedDB helpers for saving loops in-browser
        const openDb = () => new Promise((resolve, reject) => {
          if (idbRef.current.db) return resolve(idbRef.current.db);
          const req = indexedDB.open('fretlab', 1);
          req.onupgradeneeded = (e) => {
            const db = req.result;
            if (!db.objectStoreNames.contains('loops')) {
              const store = db.createObjectStore('loops', { keyPath: 'id', autoIncrement: true });
              store.createIndex('createdAt', 'createdAt');
            }
          };
          req.onsuccess = () => { idbRef.current.db = req.result; resolve(req.result); };
          req.onerror = () => reject(req.error);
        });

        const listLoops = async () => {
          const db = await openDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction('loops', 'readonly');
            const store = tx.objectStore('loops');
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result.sort((a,b)=>b.createdAt - a.createdAt));
            req.onerror = () => reject(req.error);
          });
        };

        const saveLoopToDb = async (name) => {
          if (!recordedAudio) return null;
          const db = await openDb();
          const meta = {
            name: name || `Loop ${new Date().toLocaleString()}`,
            createdAt: Date.now(),
            bpm,
            key: selectedKey,
            progressionName: selectedProgression !== null ? chordProgressions[selectedProgression].name : null,
            blob: recordedAudio,
          };
          return new Promise((resolve, reject) => {
            const tx = db.transaction('loops', 'readwrite');
            const store = tx.objectStore('loops');
            const req = store.add(meta);
            req.onsuccess = async () => { setSavedLoops(await listLoops()); resolve(req.result); };
            req.onerror = () => reject(req.error);
          });
        };

        const deleteLoop = async (id) => {
          const db = await openDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction('loops', 'readwrite');
            const store = tx.objectStore('loops');
            const req = store.delete(id);
            req.onsuccess = async () => { setSavedLoops(await listLoops()); resolve(); };
            req.onerror = () => reject(req.error);
          });
        };

        const loadLoop = async (id) => {
          const db = await openDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction('loops', 'readonly');
            const store = tx.objectStore('loops');
            const req = store.get(id);
            req.onsuccess = async () => {
              const item = req.result;
              if (!item) return resolve(null);
              setRecordedAudio(item.blob);
              setOriginalAudio(item.blob); // Set as original
              setUndoStack([]); // Clear undo history
              // Re-decode for waveform
              jamModeRef.current.audioBuffer = null;
              setAudioDuration(0);
              setCropStart(0);
              setCropEnd(0);
              setTimeout(async () => {
                try {
                  await ensureWaveformBuffer();
                  drawWaveform();
                } catch {}
              }, 0);
              resolve(item);
            };
            req.onerror = () => reject(req.error);
          });
        };

        React.useEffect(() => {
          (async () => {
            try {
              await openDb();
              setSavedLoops(await listLoops());
            } catch {}
          })();
        }, []);

        const cropAudio = async () => {
          if (!recordedAudio || audioDuration === 0) return;
          
          const startTime = Math.max(0, Math.min(cropStart, audioDuration - 0.1));
          const endTime = Math.min(audioDuration, Math.max(cropEnd, startTime + 0.1));
          
          if (endTime <= startTime) {
            alert('End time must be greater than start time');
            return;
          }

          setIsCropping(true);
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioUrl = URL.createObjectURL(recordedAudio);
            const response = await fetch(audioUrl);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const sampleRate = audioBuffer.sampleRate;
            const startSample = Math.floor(startTime * sampleRate);
            const endSample = Math.floor(endTime * sampleRate);
            const length = endSample - startSample;
            
            // Create new audio buffer with cropped portion
            const croppedBuffer = audioContext.createBuffer(
              audioBuffer.numberOfChannels,
              length,
              sampleRate
            );
            
            for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
              const oldData = audioBuffer.getChannelData(channel);
              const newData = croppedBuffer.getChannelData(channel);
              for (let i = 0; i < length; i++) {
                newData[i] = oldData[startSample + i];
              }
            }
            
            // Convert back to WAV blob
            const wav = audioBufferToWav(croppedBuffer);
            const croppedBlob = new Blob([wav], { type: 'audio/wav' });

            // Stop any active playback before updating to new cropped version
            if (isPlaying) {
              stopPlayback();
            }
            
            // Store original before trimming if not already stored
            if (!originalAudio) {
              setOriginalAudio(recordedAudio);
            }
            
            // Push current state to undo stack before applying trim
            setUndoStack(prev => [...prev, {
              audio: recordedAudio,
              audioBuffer: jamModeRef.current.audioBuffer ? jamModeRef.current.audioBuffer : null,
              cropStart,
              cropEnd,
              duration: audioDuration
            }]);
            
            // Update state and in-memory buffer so the waveform itself is trimmed
            setRecordedAudio(croppedBlob);
            jamModeRef.current.audioBuffer = croppedBuffer;
            const newDuration = endTime - startTime;
            setAudioDuration(newDuration);
            setCropStart(0);
            setCropEnd(newDuration);
            // Clear any previous audio source nodes
            if (jamModeRef.current.sourceNode) {
              try {
                jamModeRef.current.sourceNode.pause();
                jamModeRef.current.sourceNode = null;
              } catch {}
            }
            // Redraw waveform to reflect new buffer size
            setTimeout(() => { try { drawWaveform(); } catch (_) {} }, 0);

            URL.revokeObjectURL(audioUrl);
            audioContext.close();
          } catch (e) {
            console.error('Error cropping audio:', e);
            alert('Error cropping audio. Please try again.');
          } finally {
            setIsCropping(false);
          }
        };

        // Waveform rendering and drag-to-trim
        const drawWaveform = () => {
          const canvas = document.getElementById('waveform-canvas');
          if (!canvas || !jamModeRef.current.audioBuffer) return;
          const ctx = canvas.getContext('2d');
          const { width, height } = canvas;
          const mid = Math.floor(height / 2);
          ctx.clearRect(0, 0, width, height);

          // Background
          ctx.fillStyle = darkMode ? '#0f172a' : '#f1f5f9';
          ctx.fillRect(0, 0, width, height);

          // Center line
          ctx.strokeStyle = darkMode ? '#334155' : '#94a3b8';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, mid);
          ctx.lineTo(width, mid);
          ctx.stroke();

          const buffer = jamModeRef.current.audioBuffer;
          const channelData = buffer.getChannelData(0);
          const samplesPerPixel = Math.max(1, Math.floor(channelData.length / width));

          // Waveform
          ctx.strokeStyle = darkMode ? '#38bdf8' : '#0ea5e9';
          ctx.lineWidth = 1;
          ctx.beginPath();
          for (let x = 0; x < width; x++) {
            const start = x * samplesPerPixel;
            let min = 1.0, max = -1.0;
            for (let i = 0; i < samplesPerPixel; i++) {
              const s = channelData[start + i] || 0;
              if (s < min) min = s;
              if (s > max) max = s;
            }
            const y1 = mid + min * (height / 2 - 4);
            const y2 = mid + max * (height / 2 - 4);
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
          }
          ctx.stroke();

          // Dim areas that will be cut (outside selection) - use refs for current drag values
          const currentStart = waveformRef.current.currentCropStart ?? cropStart;
          const currentEnd = waveformRef.current.currentCropEnd ?? cropEnd;
          const toX = (sec) => Math.round((sec / audioDuration) * width);
          const selX1 = toX(Math.max(0, Math.min(audioDuration, currentStart)));
          const selX2 = toX(Math.max(0, Math.min(audioDuration, currentEnd)));
          
          // Dim left side (will be cut)
          ctx.fillStyle = darkMode ? 'rgba(239,68,68,0.25)' : 'rgba(239,68,68,0.15)';
          ctx.fillRect(0, 0, selX1, height);
          // Dim right side (will be cut)
          ctx.fillRect(selX2, 0, width - selX2, height);
          
          // Highlight selection area (will be kept)
          ctx.fillStyle = darkMode ? 'rgba(34,197,94,0.25)' : 'rgba(34,197,94,0.2)';
          ctx.fillRect(selX1, 0, Math.max(2, selX2 - selX1), height);
          
          // Border around selection
          ctx.strokeStyle = darkMode ? '#22c55e' : '#16a34a';
          ctx.lineWidth = 2;
          ctx.strokeRect(selX1, 0, Math.max(2, selX2 - selX1), height);

          // Handles - larger and more visible
          const handleWidth = 8;
          const handleHitWidth = 20; // Larger hit area for easier grabbing
          ctx.fillStyle = darkMode ? '#22c55e' : '#16a34a';
          // Left handle
          ctx.fillRect(selX1 - handleWidth / 2, 0, handleWidth, height);
          // Handle grip lines for visual feedback
          ctx.strokeStyle = darkMode ? '#16a34a' : '#15803d';
          ctx.lineWidth = 2;
          for (let i = 0; i < 3; i++) {
            const yPos = (height / 4) * (i + 1);
            ctx.beginPath();
            ctx.moveTo(selX1 - handleWidth / 2 + 2, yPos);
            ctx.lineTo(selX1 + handleWidth / 2 - 2, yPos);
            ctx.stroke();
          }
          // Right handle
          ctx.fillStyle = darkMode ? '#22c55e' : '#16a34a';
          ctx.fillRect(selX2 - handleWidth / 2, 0, handleWidth, height);
          ctx.strokeStyle = darkMode ? '#16a34a' : '#15803d';
          for (let i = 0; i < 3; i++) {
            const yPos = (height / 4) * (i + 1);
            ctx.beginPath();
            ctx.moveTo(selX2 - handleWidth / 2 + 2, yPos);
            ctx.lineTo(selX2 + handleWidth / 2 - 2, yPos);
            ctx.stroke();
          }
        };

        const ensureWaveformBuffer = async () => {
          if (!recordedAudio || jamModeRef.current.audioBuffer) return;
          const audioUrl = URL.createObjectURL(recordedAudio);
          try {
            const resp = await fetch(audioUrl);
            const arr = await resp.arrayBuffer();
            const ac = new (window.AudioContext || window.webkitAudioContext)();
            const decoded = await ac.decodeAudioData(arr);
            jamModeRef.current.audioBuffer = decoded;
            if (!audioDuration || audioDuration === 0) {
              setAudioDuration(decoded.duration);
              setCropEnd(decoded.duration);
            }
          } catch (e) {
            console.error('Waveform decode failed', e);
          } finally {
            URL.revokeObjectURL(audioUrl);
          }
        };

        React.useEffect(() => {
          if (!showCropUI || !recordedAudio) return;
          let down = false;
          let rafId = null;
          const canvas = document.getElementById('waveform-canvas');
          if (!canvas) return;
          
          // Local drawWaveform that uses current state values
          const drawWaveformLocal = () => {
            if (!canvas || !jamModeRef.current.audioBuffer) return;
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const mid = Math.floor(height / 2);
            ctx.clearRect(0, 0, width, height);

            // Background
            ctx.fillStyle = darkMode ? '#0f172a' : '#f1f5f9';
            ctx.fillRect(0, 0, width, height);

            // Center line
            ctx.strokeStyle = darkMode ? '#334155' : '#94a3b8';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, mid);
            ctx.lineTo(width, mid);
            ctx.stroke();

            const buffer = jamModeRef.current.audioBuffer;
            const channelData = buffer.getChannelData(0);
            const samplesPerPixel = Math.max(1, Math.floor(channelData.length / width));

            // Waveform
            ctx.strokeStyle = darkMode ? '#38bdf8' : '#0ea5e9';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
              const start = x * samplesPerPixel;
              let min = 1.0, max = -1.0;
              for (let i = 0; i < samplesPerPixel; i++) {
                const s = channelData[start + i] || 0;
                if (s < min) min = s;
                if (s > max) max = s;
              }
              const y1 = mid + min * (height / 2 - 4);
              const y2 = mid + max * (height / 2 - 4);
              ctx.moveTo(x, y1);
              ctx.lineTo(x, y2);
            }
            ctx.stroke();

            // Get current crop values - use refs for immediate updates during drag
            const currentStart = waveformRef.current.currentCropStart ?? cropStart;
            const currentEnd = waveformRef.current.currentCropEnd ?? cropEnd;
            const currentDuration = audioDuration;

            // Dim areas that will be cut (outside selection)
            const toX = (sec) => Math.round((sec / currentDuration) * width);
            const selX1 = toX(Math.max(0, Math.min(currentDuration, currentStart)));
            const selX2 = toX(Math.max(0, Math.min(currentDuration, currentEnd)));
            
            // Dim left side (will be cut)
            ctx.fillStyle = darkMode ? 'rgba(239,68,68,0.25)' : 'rgba(239,68,68,0.15)';
            ctx.fillRect(0, 0, selX1, height);
            // Dim right side (will be cut)
            ctx.fillRect(selX2, 0, width - selX2, height);
            
            // Highlight selection area (will be kept)
            ctx.fillStyle = darkMode ? 'rgba(34,197,94,0.25)' : 'rgba(34,197,94,0.2)';
            ctx.fillRect(selX1, 0, Math.max(2, selX2 - selX1), height);
            
            // Border around selection
            ctx.strokeStyle = darkMode ? '#22c55e' : '#16a34a';
            ctx.lineWidth = 2;
            ctx.strokeRect(selX1, 0, Math.max(2, selX2 - selX1), height);

            // Progress bar - black vertical indicator showing playback position
            if (isPlaying && playbackTime > 0 && currentDuration > 0) {
              const playbackX = toX(playbackTime);
              
              // Draw black vertical progress bar
              ctx.fillStyle = '#000000'; // Black color
              ctx.fillRect(playbackX - 2, 0, 4, height); // 4px wide vertical bar
              
              // Optional: Add a small triangle or circle at the top for better visibility
              ctx.fillStyle = '#000000';
              ctx.beginPath();
              ctx.moveTo(playbackX - 6, 0);
              ctx.lineTo(playbackX + 6, 0);
              ctx.lineTo(playbackX, 12);
              ctx.closePath();
              ctx.fill();
            }

            // Handles - larger and more visible
            const handleWidth = 8;
            ctx.fillStyle = darkMode ? '#22c55e' : '#16a34a';
            // Left handle
            ctx.fillRect(selX1 - handleWidth / 2, 0, handleWidth, height);
            // Handle grip lines for visual feedback
            ctx.strokeStyle = darkMode ? '#16a34a' : '#15803d';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
              const yPos = (height / 4) * (i + 1);
              ctx.beginPath();
              ctx.moveTo(selX1 - handleWidth / 2 + 2, yPos);
              ctx.lineTo(selX1 + handleWidth / 2 - 2, yPos);
              ctx.stroke();
            }
            // Right handle
            ctx.fillStyle = darkMode ? '#22c55e' : '#16a34a';
            ctx.fillRect(selX2 - handleWidth / 2, 0, handleWidth, height);
            ctx.strokeStyle = darkMode ? '#16a34a' : '#15803d';
            for (let i = 0; i < 3; i++) {
              const yPos = (height / 4) * (i + 1);
              ctx.beginPath();
              ctx.moveTo(selX2 - handleWidth / 2 + 2, yPos);
              ctx.lineTo(selX2 + handleWidth / 2 - 2, yPos);
              ctx.stroke();
            }
          };
          
          const onResize = () => {
            if (canvas) drawWaveformLocal();
          };
          const getSecFromX = (clientX) => {
            const rect = canvas.getBoundingClientRect();
            const relX = Math.max(0, Math.min(rect.width, clientX - rect.left));
            const sec = (relX / rect.width) * (audioDuration || 1);
            return Math.max(0, Math.min(audioDuration || 1, sec));
          };
          
          const onDown = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = clientX - rect.left;
            const width = rect.width;
            const startX = (cropStart / (audioDuration || 1)) * width;
            const endX = (cropEnd / (audioDuration || 1)) * width;
            const handleHitWidth = 30; // Large hit area for easy grabbing
            
            // Determine what we're dragging
            const distToStart = Math.abs(x - startX);
            const distToEnd = Math.abs(x - endX);
            const isNearStart = distToStart < handleHitWidth;
            const isNearEnd = distToEnd < handleHitWidth;
            const isInSelection = x >= startX && x <= endX && !isNearStart && !isNearEnd;
            
            if (isNearStart && distToStart <= distToEnd) {
              // Dragging start handle
              waveformRef.current.dragging = 'start';
              waveformRef.current.dragStartX = x;
            } else if (isNearEnd) {
              // Dragging end handle
              waveformRef.current.dragging = 'end';
              waveformRef.current.dragStartX = x;
            } else if (isInSelection) {
              // Dragging entire selection
              waveformRef.current.dragging = 'move';
              waveformRef.current.dragStartX = x;
              waveformRef.current.dragOffset = x - startX;
            } else {
              // Clicked outside - snap nearest handle to click position
              const clickSec = getSecFromX(clientX);
              if (x < startX) {
                // Click before start
                waveformRef.current.dragging = 'start';
                waveformRef.current.dragStartX = x;
                const newStart = Math.max(0, Math.min(clickSec, cropEnd - 0.05));
                setCropStart(newStart);
                waveformRef.current.currentCropStart = newStart;
              } else {
                // Click after end
                waveformRef.current.dragging = 'end';
                waveformRef.current.dragStartX = x;
                const newEnd = Math.min(audioDuration, Math.max(clickSec, cropStart + 0.05));
                setCropEnd(newEnd);
                waveformRef.current.currentCropEnd = newEnd;
              }
            }
            down = true;
            canvas.setPointerCapture?.(e.pointerId || 0); // Capture pointer for smooth dragging
          };
          
          const onMove = (e) => {
            if (!down || !waveformRef.current.dragging) return;
            e.preventDefault();
            e.stopPropagation();
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = clientX - rect.left;
            const width = rect.width;
            const sec = getSecFromX(clientX);
            
            if (waveformRef.current.dragging === 'start') {
              const newStart = Math.max(0, Math.min(sec, cropEnd - 0.05));
              waveformRef.current.currentCropStart = newStart;
              setCropStart(newStart);
            } else if (waveformRef.current.dragging === 'end') {
              const newEnd = Math.min(audioDuration, Math.max(sec, cropStart + 0.05));
              waveformRef.current.currentCropEnd = newEnd;
              setCropEnd(newEnd);
            } else if (waveformRef.current.dragging === 'move') {
              // Move entire selection while maintaining width
              const selectionWidth = cropEnd - cropStart;
              const offsetInSec = (waveformRef.current.dragOffset / width) * audioDuration;
              const newStart = Math.max(0, Math.min(sec - offsetInSec, audioDuration - selectionWidth));
              const newEnd = Math.min(audioDuration, newStart + selectionWidth);
              waveformRef.current.currentCropStart = newStart;
              waveformRef.current.currentCropEnd = newEnd;
              setCropStart(newStart);
              setCropEnd(newEnd);
            }
            
            // Continuous redraw for smooth dragging
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
              drawWaveformLocal();
              rafId = null;
            });
          };
          const onUp = (e) => {
            down = false;
            if (rafId) {
              cancelAnimationFrame(rafId);
              rafId = null;
            }
            canvas.releasePointerCapture?.(e.pointerId || 0);
            waveformRef.current.dragging = null;
            waveformRef.current.dragStartX = null;
            waveformRef.current.dragOffset = null;
            // Clear refs so we use state values after drag
            waveformRef.current.currentCropStart = null;
            waveformRef.current.currentCropEnd = null;
            drawWaveformLocal(); // Final redraw with state values
          };

          // Set up canvas for smooth interaction
          canvas.style.userSelect = 'none';
          canvas.style.touchAction = 'none';
          canvas.style.cursor = 'pointer';
          
          (async () => {
            await ensureWaveformBuffer();
            // Initialize refs to current state
            waveformRef.current.currentCropStart = cropStart;
            waveformRef.current.currentCropEnd = cropEnd;
            drawWaveformLocal();
          })();

          const onHover = (e) => {
            if (!canvas || down) return; // Don't change cursor while dragging
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            const startX = (cropStart / (audioDuration || 1)) * width;
            const endX = (cropEnd / (audioDuration || 1)) * width;
            const handleHitWidth = 25;
            
            const distToStart = Math.abs(x - startX);
            const distToEnd = Math.abs(x - endX);
            
            if (distToStart < handleHitWidth || distToEnd < handleHitWidth) {
              canvas.style.cursor = 'ew-resize'; // Resize cursor for handles
            } else if (x >= startX && x <= endX) {
              canvas.style.cursor = 'grab'; // Grab cursor for selection area
            } else {
              canvas.style.cursor = 'pointer'; // Pointer for clicking to set trim points
            }
          };

          window.addEventListener('resize', onResize);
          
          // Pointer move handler (for both hover and drag)
          const pointerMoveHandler = (e) => {
            if (!down) {
              onHover(e);
            } else {
              onMove(e);
            }
          };
          
          // Mouse move handler (for both hover and drag)
          const mouseMoveHandler = (e) => {
            if (!down) {
              onHover(e);
            } else {
              onMove(e);
            }
          };
          
          // Use pointer events for better cross-device support
          canvas.addEventListener('pointerdown', onDown);
          canvas.addEventListener('pointermove', pointerMoveHandler);
          window.addEventListener('pointerup', onUp);
          window.addEventListener('pointercancel', onUp);
          // Fallback for older browsers
          canvas.addEventListener('mousedown', onDown);
          canvas.addEventListener('mousemove', mouseMoveHandler);
          window.addEventListener('mouseup', onUp);
          // Touch events for mobile
          canvas.addEventListener('touchstart', onDown, { passive: false });
          canvas.addEventListener('touchmove', onMove, { passive: false });
          window.addEventListener('touchend', onUp);
          window.addEventListener('touchcancel', onUp);
          return () => {
            if (canvas) canvas.style.cursor = 'default';
            if (rafId) cancelAnimationFrame(rafId);
            window.removeEventListener('resize', onResize);
            // Pointer events
            canvas.removeEventListener('pointerdown', onDown);
            canvas.removeEventListener('pointermove', pointerMoveHandler);
            window.removeEventListener('pointerup', onUp);
            window.removeEventListener('pointercancel', onUp);
            // Mouse events (fallback)
            canvas.removeEventListener('mousedown', onDown);
            canvas.removeEventListener('mousemove', mouseMoveHandler);
            window.removeEventListener('mouseup', onUp);
            // Touch events
            canvas.removeEventListener('touchstart', onDown);
            canvas.removeEventListener('touchmove', onMove);
            window.removeEventListener('touchend', onUp);
            window.removeEventListener('touchcancel', onUp);
          };
        }, [showCropUI, recordedAudio, cropStart, cropEnd, audioDuration, darkMode, isPlaying, playbackTime]);

        React.useEffect(() => {
          if (showCropUI && jamModeRef.current.audioBuffer) {
            // Sync refs when state changes (when not dragging)
            if (!waveformRef.current.dragging) {
              waveformRef.current.currentCropStart = cropStart;
              waveformRef.current.currentCropEnd = cropEnd;
            }
            drawWaveform();
          }
        }, [showCropUI, cropStart, cropEnd, audioDuration, darkMode, playbackTime]);
        
        // Continuously redraw waveform during playback for smooth indicator movement
        React.useEffect(() => {
          if (!isPlaying || !showCropUI) return;
          let rafId = null;
          const animate = () => {
            drawWaveform();
            rafId = requestAnimationFrame(animate);
          };
          rafId = requestAnimationFrame(animate);
          return () => {
            if (rafId) cancelAnimationFrame(rafId);
          };
        }, [isPlaying, showCropUI]);

        // Helper function to convert AudioBuffer to WAV
        const audioBufferToWav = (buffer) => {
          const length = buffer.length * buffer.numberOfChannels * 2 + 44;
          const arrayBuffer = new ArrayBuffer(length);
          const view = new DataView(arrayBuffer);
          const channels = [];
          let offset = 0;
          let pos = 0;

          // Write WAV header
          const setUint16 = (data) => {
            view.setUint16(pos, data, true);
            pos += 2;
          };
          const setUint32 = (data) => {
            view.setUint32(pos, data, true);
            pos += 4;
          };

          setUint32(0x46464952); // "RIFF"
          setUint32(length - 8); // file length - 8
          setUint32(0x45564157); // "WAVE"
          setUint32(0x20746d66); // "fmt " chunk
          setUint32(16); // chunk size
          setUint16(1); // audio format (1 = PCM)
          setUint16(buffer.numberOfChannels);
          setUint32(buffer.sampleRate);
          setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels); // byte rate
          setUint16(buffer.numberOfChannels * 2); // block align
          setUint16(16); // bits per sample
          setUint32(0x61746164); // "data" chunk
          setUint32(length - pos - 4);

          // Write audio data
          for (let i = 0; i < buffer.numberOfChannels; i++) {
            channels.push(buffer.getChannelData(i));
          }
          while (pos < length) {
            for (let i = 0; i < buffer.length; i++) {
              for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                let sample = Math.max(-1, Math.min(1, channels[channel][i]));
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
              }
            }
          }

          return arrayBuffer;
        };

        // Cleanup on unmount
        React.useEffect(() => {
          return () => {
            if (jamModeRef.current.countdownInterval) {
              clearInterval(jamModeRef.current.countdownInterval);
            }
            if (jamModeRef.current.countdownTimeouts && jamModeRef.current.countdownTimeouts.length) {
              jamModeRef.current.countdownTimeouts.forEach(t => clearTimeout(t));
              jamModeRef.current.countdownTimeouts = [];
            }
            if (jamModeRef.current.mediaRecorder && jamModeRef.current.mediaRecorder.state !== 'inactive') {
              jamModeRef.current.mediaRecorder.stop();
            }
          };
        }, []);

        // Helpers: note name to midi and freq
        const noteNameToMidi = (name, octave) => {
          const idx = noteNames.indexOf(name);
          if (idx < 0) return null;
          return (octave + 1) * 12 + idx; // MIDI formula
        };
        const midiToFreq = (midi) => 440 * Math.pow(2, (midi - 69) / 12);
        const buildTargetFreqs = (presetKey) => {
          // Default octaves per string low->high for standard: E2 A2 D3 G3 B3 E4
          const baseOctavesStandard = [2,2,3,3,3,4];
          const names = tuningPresets[presetKey];
          if (!names) return [];
          // Adjust low string for dropD and halfStepDown
          const octaves = [...baseOctavesStandard];
          if (presetKey === 'dropD') octaves[0] = 2; // D2
          if (presetKey === 'halfStepDown') {
            // E2->D#2 etc., octaves unchanged
          }
          return names.map((n, i) => {
            const midi = noteNameToMidi(n, octaves[i]);
            return midi != null ? midiToFreq(midi) : null;
          });
        };
        const targetFreqs = buildTargetFreqs(tuning);

        // Pluck sound synth
        const pluckRef = React.useRef({ audioCtx: null });
        const playPluck = (freq, idx = null) => {
          try {
            const ctx = pluckRef.current.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            pluckRef.current.audioCtx = ctx;

            const duration = 2.2;
            const now = ctx.currentTime;

            // Multiple oscillators with detuning for natural beating
            const osc1 = ctx.createOscillator();
            const osc2 = ctx.createOscillator();
            const osc3 = ctx.createOscillator();
            osc1.type = 'triangle';
            osc2.type = 'triangle';
            osc3.type = 'sine';
            osc1.frequency.setValueAtTime(freq, now);
            osc2.frequency.setValueAtTime(freq * 0.996, now);
            osc3.frequency.setValueAtTime(freq * 2, now); // octave harmonic

            // Realistic guitar string filtering
            const lp1 = ctx.createBiquadFilter();
            lp1.type = 'lowpass';
            lp1.frequency.setValueAtTime(3000, now);
            lp1.frequency.exponentialRampToValueAtTime(1800, now + 0.1);
            lp1.Q.setValueAtTime(0.8, now);

            // Acoustic body resonance peaks
            const body1 = ctx.createBiquadFilter();
            body1.type = 'peaking';
            body1.frequency.setValueAtTime(180 + freq * 0.1, now);
            body1.gain.setValueAtTime(8, now);
            body1.Q.setValueAtTime(2, now);
            const body2 = ctx.createBiquadFilter();
            body2.type = 'peaking';
            body2.frequency.setValueAtTime(300 + freq * 0.15, now);
            body2.gain.setValueAtTime(6, now);
            body2.Q.setValueAtTime(1.5, now);

            // More realistic pick attack (filtered noise)
            const attackLen = 0.08 * ctx.sampleRate;
            const noiseBuf = ctx.createBuffer(1, attackLen, ctx.sampleRate);
            const data = noiseBuf.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              const t = i / ctx.sampleRate;
              data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 60) * (1 - t / 0.08);
            }
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuf;
            const noiseGain = ctx.createGain();
            noiseGain.gain.setValueAtTime(0.25, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

            // String damping over time
            const damping = ctx.createGain();
            damping.gain.setValueAtTime(1, now);
            damping.gain.exponentialRampToValueAtTime(0.3, now + 0.5);
            damping.gain.exponentialRampToValueAtTime(0.001, now + duration);

            // Master envelope (boost G/B strings louder, D string moderate)
            const gain = ctx.createGain();
            let baseVolume = 0.6;
            if (idx === 3 || idx === 4) baseVolume = 1.0; // G and B strings (idx 3, 4) louder
            else if (idx === 2) baseVolume = 0.85; // D string (idx 2) moderate boost
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(baseVolume, now + 0.008);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            // Subtle stereo chorus for width
            const delay = ctx.createDelay(0.1);
            delay.delayTime.setValueAtTime(0.008, now);
            const feedback = ctx.createGain();
            feedback.gain.setValueAtTime(0.12, now);

            // Connect graph
            osc1.connect(lp1);
            osc2.connect(lp1);
            osc3.connect(lp1);
            noise.connect(noiseGain).connect(lp1);
            lp1.connect(body1).connect(body2).connect(damping).connect(delay);
            delay.connect(feedback).connect(delay);
            body2.connect(gain);
            delay.connect(gain);
            gain.connect(ctx.destination);

            // Start/stop
            osc1.start(now);
            osc2.start(now);
            osc3.start(now);
            noise.start(now);
            osc1.stop(now + duration);
            osc2.stop(now + duration);
            osc3.stop(now + duration);
            noise.stop(now + 0.08);
          } catch (e) {
            /* no-op */
          }
        };

        // Sample-based playback (optional assets)
        const sampleRef = React.useRef({ audioCtx: null, cache: new Map() });
        const getStringNameAndOctave = (presetKey, idx) => {
          const baseOctavesStandard = [2,2,3,3,3,4];
          const names = tuningPresets[presetKey];
          if (!names || idx < 0 || idx >= names.length) return null;
          const octaves = [...baseOctavesStandard];
          if (presetKey === 'dropD') octaves[0] = 2;
          return { name: names[idx], octave: octaves[idx] };
        };
        const playStringSample = async (idx) => {
          try {
            const ctx = sampleRef.current.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            sampleRef.current.audioCtx = ctx;
            const info = getStringNameAndOctave(tuning, idx);
            if (!info) throw new Error('no note info');
            const tuningFolderMap = { standard: 'standard', dropD: 'dropD', halfStepDown: 'halfStepDown' };
            const folder = tuningFolderMap[tuning] || 'standard';
            const fileBase = `assets/samples/${folder}/${encodeURIComponent(info.name + info.octave)}`;
            const tryUrls = [`${fileBase}.mp3`, `${fileBase}.wav`];
            let buffer = null;
            for (const url of tryUrls) {
              const key = url;
              if (sampleRef.current.cache.has(key)) {
                buffer = sampleRef.current.cache.get(key);
                break;
              }
              const res = await fetch(url);
              if (res.ok) {
                const arr = await res.arrayBuffer();
                buffer = await ctx.decodeAudioData(arr.slice(0));
                sampleRef.current.cache.set(key, buffer);
                break;
              }
            }
            if (!buffer) throw new Error('sample not found');
            const src = ctx.createBufferSource();
            src.buffer = buffer;
            const gain = ctx.createGain();
            // Boost G (idx 3) and B (idx 4) strings louder, D (idx 2) moderate boost
            let baseGain = 0.9;
            if (idx === 3 || idx === 4) baseGain = 1.7; // G and B strings louder
            else if (idx === 2) baseGain = 1.4; // D string moderate boost
            gain.gain.setValueAtTime(baseGain, ctx.currentTime);
            src.connect(gain).connect(ctx.destination);
            src.start();
            return true;
          } catch (e) {
            return false;
          }
        };
        const playStringSound = async (idx) => {
          const ok = await playStringSample(idx);
          if (!ok) {
            const tf = targetFreqs && targetFreqs[idx];
            if (tf) playPluck(tf, idx);
          }
        };

        React.useEffect(() => {
          // Reset confirmation when tuning preset or selected string changes
          setStringHoldStart(null);
          setStringConfirmed(false);
        }, [tuning, selectedString]);

        React.useEffect(() => {
          if (!isTunerOn) {
            setStringHoldStart(null);
            setStringConfirmed(false);
            return;
          }
          // Auto-detect likely string based on nearest target frequency
          if (autoDetectString && tunerFreq > 0 && targetFreqs && targetFreqs.length === 6) {
            let bestIdx = selectedString;
            let bestDiff = Infinity;
            for (let i = 0; i < targetFreqs.length; i++) {
              const tf = targetFreqs[i];
              if (!tf) continue;
              const centsDiff = 1200 * Math.log2(tunerFreq / tf);
              const absDiff = Math.abs(centsDiff);
              if (absDiff < bestDiff) {
                bestDiff = absDiff;
                bestIdx = i;
              }
            }
            if (bestIdx !== selectedString) setSelectedString(bestIdx);
          }
          const target = tuningPresets[tuning][selectedString];
          const inTune = target && tunerNote === target && Math.abs(tunerCents) <= 5;
          if (inTune) {
            if (!stringHoldStart) {
              setStringHoldStart(performance.now());
            } else if (!stringConfirmed && performance.now() - stringHoldStart >= 3000) {
              setStringConfirmed(true);
            }
          } else {
            setStringHoldStart(null);
            setStringConfirmed(false);
          }
        }, [tunerNote, tunerCents, tunerFreq, tuning, selectedString, isTunerOn, stringHoldStart, stringConfirmed, autoDetectString, targetFreqs]);

        const freqToNoteInfo = (freq) => {
          if (!freq || !isFinite(freq) || freq <= 0) return null;
          const midi = Math.round(69 + 12 * Math.log2(freq / 440));
          const name = noteNames[(midi + 1200) % 12];
          const noteFreq = 440 * Math.pow(2, (midi - 69) / 12);
          const cents = Math.round(1200 * Math.log2(freq / noteFreq));
          return { name, freq: noteFreq, cents, midi };
        };

        const autoCorrelate = (buf, sampleRate) => {
          // Autocorrelation-based pitch detection
          const SIZE = buf.length;
          let rms = 0;
          for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
          rms = Math.sqrt(rms / SIZE);
          if (rms < 0.01) return -1; // too low signal

          let r1 = 0, r2 = SIZE - 1, thres = 0.2;
          for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
          for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
          buf = buf.slice(r1, r2);
          const newSize = buf.length;
          const c = new Array(newSize).fill(0);
          for (let i = 0; i < newSize; i++) {
            for (let j = 0; j < newSize - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
          }
          let d = 0; while (c[d] > c[d + 1]) d++;
          let maxval = -1, maxpos = -1;
          for (let i = d; i < newSize; i++) {
            if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
          }
          let T0 = maxpos;
          if (T0 > 0 && T0 < newSize - 1) {
            const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            const a = (x1 + x3 - 2 * x2) / 2;
            const b = (x3 - x1) / 2;
            if (a) T0 = T0 - b / (2 * a);
          }
          const freq = sampleRate / T0;
          return freq;
        };

        const startTuner = async () => {
          try {
            setTunerError(null);
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
            const source = audioCtx.createMediaStreamSource(stream);
            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);
            const buf = new Float32Array(analyser.fftSize);
            tunerRef.current = { audioCtx, analyser, source, stream, rafId: null, buf };

            const tick = () => {
              analyser.getFloatTimeDomainData(buf);
              const freq = autoCorrelate(buf, audioCtx.sampleRate);
              if (freq > 0 && isFinite(freq) && freq < 2000) {
                setTunerFreq(freq);
                const info = freqToNoteInfo(freq);
                if (info) {
                  setTunerNote(info.name);
                  setTunerCents(Math.max(-50, Math.min(50, info.cents)));
                }
              }
              tunerRef.current.rafId = requestAnimationFrame(tick);
            };
            setIsTunerOn(true);
            tick();
          } catch (e) {
            setTunerError(String(e && e.message ? e.message : e));
            setIsTunerOn(false);
          }
        };

        const stopTuner = () => {
          const ref = tunerRef.current;
          if (ref.rafId) cancelAnimationFrame(ref.rafId);
          if (ref.stream) ref.stream.getTracks().forEach(t => t.stop());
          if (ref.audioCtx) ref.audioCtx.close();
          tunerRef.current = { audioCtx: null, analyser: null, source: null, stream: null, rafId: null, buf: null };
          setIsTunerOn(false);
          setTunerFreq(0);
          setTunerNote('-');
          setTunerCents(0);
        };

        // sound removed

        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        const strings = [
          { name: 'e', openNote: 4 },
          { name: 'B', openNote: 11 },
          { name: 'G', openNote: 7 },
          { name: 'D', openNote: 2 },
          { name: 'A', openNote: 9 },
          { name: 'E', openNote: 4 }
        ];

        const scales = {
          major: [0, 2, 4, 5, 7, 9, 11],
          minor: [0, 2, 3, 5, 7, 8, 10],
          pentatonicMajor: [0, 2, 4, 7, 9],
          pentatonicMinor: [0, 3, 5, 7, 10],
          blues: [0, 3, 5, 6, 7, 10],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
          melodicMinor: [0, 2, 3, 5, 7, 9, 11]
        };

        const scaleNames = {
          major: 'Major',
          minor: 'Natural Minor',
          pentatonicMajor: 'Pentatonic Major',
          pentatonicMinor: 'Pentatonic Minor',
          blues: 'Blues',
          dorian: 'Dorian',
          phrygian: 'Phrygian',
          lydian: 'Lydian',
          mixolydian: 'Mixolydian',
          locrian: 'Locrian',
          harmonicMinor: 'Harmonic Minor',
          melodicMinor: 'Melodic Minor'
        };

        const getScaleNotes = useMemo(() => {
          const rootIndex = notes.indexOf(rootNote);
          const intervals = scales[scaleType];
          return intervals.map(interval => (rootIndex + interval) % 12);
        }, [rootNote, scaleType]);

        const isNoteInScale = (noteIndex) => {
          return getScaleNotes.includes(noteIndex % 12);
        };

        const getScaleDegree = (noteIndex) => {
          const normalizedNote = noteIndex % 12;
          const degreeIndex = getScaleNotes.indexOf(normalizedNote);
          return degreeIndex !== -1 ? degreeIndex + 1 : null;
        };

        const formatDegree = (degree, noteIndex) => {
          if (!degree) return null;
          
          // Get the interval for this degree in the current scale
          const interval = scales[scaleType][degree - 1];
          
          // Check if this interval is flatted or sharped compared to major scale
          const majorIntervals = scales.major;
          const majorIntervalForThisPosition = majorIntervals[Math.min(degree - 1, majorIntervals.length - 1)];
          
          if (interval < majorIntervalForThisPosition) {
            return `${degree}♭`;
          } else if (interval > majorIntervalForThisPosition) {
            return `${degree}♯`;
          }
          
          return degree;
        };

        const getNoteAtFret = (stringOpenNote, fret) => {
          return (stringOpenNote + fret) % 12;
        };

        const isRootNote = (noteIndex) => {
          return noteIndex % 12 === notes.indexOf(rootNote);
        };

        const isToneInChord = (noteIndex) => {
          if (!selectedChord || !selectedChord.pcs) return false;
          const normalizedNote = noteIndex % 12;
          return selectedChord.pcs.includes(normalizedNote);
        };

        const isChordRoot = (noteIndex) => {
          if (!selectedChord) return false;
          return (noteIndex % 12) === selectedChord.pcs[0];
        };

        const isChordThird = (noteIndex) => {
          if (!selectedChord || !selectedChord.pcs || selectedChord.pcs.length < 2) return false;
          return (noteIndex % 12) === selectedChord.pcs[1];
        };


        // --- Chords ---
        const rotateArray = (arr, start) => arr.slice(start).concat(arr.slice(0, start));
        const pcDistance = (a, b) => (b - a + 12) % 12;
        const intervalsToQualityTriad = (iv) => {
          const sig = iv.sort((x,y)=>x-y).join(',');
          if (sig === '0,4,7') return 'maj';
          if (sig === '0,3,7') return 'm';
          if (sig === '0,3,6') return 'dim';
          if (sig === '0,4,8') return 'aug';
          return '';
        };
        const intervalsToQualitySeventh = (iv) => {
          const sig = iv.sort((x,y)=>x-y).join(',');
          if (sig === '0,4,7,11') return 'maj7';
          if (sig === '0,4,7,10') return '7';
          if (sig === '0,3,7,10') return 'm7';
          if (sig === '0,3,6,10') return 'm7b5';
          if (sig === '0,3,6,9') return 'dim7';
          return '7';
        };
        const buildDiatonicChords = useMemo(() => {
          const scalePcs = getScaleNotes; // array of pitch classes (0-11)
          if (!scalePcs || scalePcs.length === 0) return [];
          const chords = [];
          for (let degree = 0; degree < scalePcs.length; degree++) {
            const rotated = rotateArray(scalePcs, degree);
            const stack = chordType === 'sevenths' ? [0,2,4,6] : [0,2,4];
            const chordPcs = stack.map(step => rotated[step % rotated.length]);
            const rootPc = chordPcs[0];
            const intervals = chordPcs.map(pc => pcDistance(rootPc, pc));
            const rootName = notes[rootPc];
            const quality = chordType === 'sevenths' ? intervalsToQualitySeventh(intervals) : intervalsToQualityTriad(intervals);
            chords.push({
              name: `${rootName}${quality}`,
              degree: degree + 1,
              pcs: chordPcs,
              quality,
            });
          }
          return chords;
        }, [getScaleNotes, chordType]);

        const visibleFretCount = Math.max(1, endFret - startFret + 1);

        return (
          <div className={`min-h-screen ${darkMode ? 'bg-[#121212]' : 'bg-gray-100'} transition-colors duration-300`}>
            <div className={`${darkMode ? 'bg-[#1c1c1c] border-[#2c2c2c]' : 'bg-white border-gray-200'} border-b`}>
            
              <div className="container mx-auto px-4 py-4">
                <div className="flex flex-wrap items-center justify-between gap-4">
                  <div className="flex items-center gap-3">
                    <button
                      onClick={() => setIsSidebarOpen(true)}
                      className={`h-10 w-10 grid place-items-center rounded-lg transition-colors ${
                        darkMode ? 'bg-slate-800 hover:bg-slate-700 text-white' : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                      }`}
                      title="Open Menu"
                    >
                      ☰
                    </button>
                  <h1 className={`text-2xl font-bold ${darkMode ? 'text-slate-100' : 'text-gray-900'}`}>
                    FretLab
                  </h1>
                  </div>
                  
                {(page === 'Explorer' || page === 'FretBoard') && (
                  <div className="flex flex-wrap items-end gap-4">
                    <div className="flex items-end gap-3">
                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Root Note
                      </label>
                      <select
                        value={rootNote}
                        onChange={(e) => setRootNote(e.target.value)}
                        className={`px-3 h-10 text-sm rounded-lg ${
                          darkMode 
                            ? 'bg-slate-800 text-white border-slate-600' 
                            : 'bg-white text-slate-900 border-slate-300'
                        } border focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      >
                        {notes.map(note => (
                          <option key={note} value={note}>{note}</option>
                        ))}
                      </select>
                    </div>
                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                          Scale Type
                      </label>
                      <select
                          value={scaleType}
                          onChange={(e) => setScaleType(e.target.value)}
                        className={`px-3 h-10 text-sm rounded-lg ${
                          darkMode 
                            ? 'bg-slate-800 text-white border-slate-600' 
                            : 'bg-white text-slate-900 border-slate-300'
                        } border focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      >
                          {Object.entries(scaleNames).map(([key, name]) => (
                            <option key={key} value={key}>{name}</option>
                          ))}
                      </select>
                      </div>
                    </div>

                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Chords
                      </label>
                      <select
                        value={chordType}
                        onChange={(e) => setChordType(e.target.value)}
                        className={`px-3 h-10 text-sm rounded-lg ${
                          darkMode 
                            ? 'bg-slate-800 text-white border-slate-600' 
                            : 'bg-white text-slate-900 border-slate-300'
                        } border focus:outline-none focus:ring-2 focus:ring-blue-500`}
                      >
                        <option value="triads">Triads</option>
                        <option value="sevenths">Sevenths</option>
                      </select>
                    </div>

                    {/* Scale Type moved next to Root Note */}

                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Root Color
                      </label>
                      <input
                        type="color"
                        value={rootColor}
                        onChange={(e) => setRootColor(e.target.value)}
                        className={`h-10 w-16 rounded border ${darkMode ? 'border-slate-600 bg-slate-800' : 'border-slate-300 bg-white'}`}
                        aria-label="Pick root note color"
                      />
                    </div>

                    <div className="flex flex-col">
                      <label className={`text-xs mb-1 ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Note Color
                      </label>
                      <input
                        type="color"
                        value={noteColor}
                        onChange={(e) => setNoteColor(e.target.value)}
                        className={`h-10 w-16 rounded border ${darkMode ? 'border-slate-600 bg-slate-800' : 'border-slate-300 bg-white'}`}
                        aria-label="Pick scale note color"
                      />
                    </div>

                    <button
                      onClick={() => setShowDegrees(!showDegrees)}
                      className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                        darkMode
                          ? 'bg-indigo-600 hover:bg-indigo-700 text-white'
                          : 'bg-indigo-500 hover:bg-indigo-600 text-white'
                      }`}
                    >
                      {showDegrees ? 'Show Notes' : 'Show Degrees'}
                    </button>

                    <div className="flex flex-col gap-1">
                      <label className={`text-xs ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                        Frets
                      </label>
                      <div className="flex items-center gap-2">
                        <input
                          type="number"
                          min="1"
                          max="21"
                          value={startFret}
                          onChange={(e) => {
                            const val = Math.max(1, Math.min(20, parseInt(e.target.value) || 1));
                            setStartFret(val);
                            if (val >= endFret) setEndFret(Math.min(21, val + 1));
                          }}
                          className={`w-16 px-2 py-1 text-sm rounded ${
                            darkMode 
                              ? 'bg-slate-800 text-white border-slate-600' 
                              : 'bg-white text-slate-900 border-slate-300'
                          } border`}
                        />
                        <span className={`text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>-</span>
                        <input
                          type="number"
                          min="1"
                          max="21"
                          value={endFret}
                          onChange={(e) => {
                            const val = Math.max(2, Math.min(21, parseInt(e.target.value) || 21));
                            setEndFret(val);
                            if (val <= startFret) setStartFret(Math.max(1, val - 1));
                          }}
                          className={`w-16 px-2 py-1 text-sm rounded ${
                            darkMode 
                              ? 'bg-slate-800 text-white border-slate-600' 
                              : 'bg-white text-slate-900 border-slate-300'
                          } border`}
                        />
                        <button
                          onClick={() => {
                            setStartFret(1);
                            setEndFret(21);
                          }}
                          className={`px-2 py-1 text-xs rounded font-medium transition-colors ${
                            darkMode
                              ? 'bg-slate-700 hover:bg-slate-600 text-white'
                              : 'bg-slate-300 hover:bg-slate-400 text-slate-900'
                          }`}
                          title="Reset to all frets"
                        >
                          Reset
                        </button>
                      </div>
                    </div>
                  </div>
                )}
                    </div>

                {(page === 'Explorer' || page === 'FretBoard') && (
                  <div className={`mt-3 text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>
                    Current Scale: <span className="font-semibold">{rootNote} {scaleNames[scaleType]}</span>
                  </div>
                )}
              </div>
            </div>

            {/* Sidebar Overlay */}
            {isSidebarOpen && (
              <div
                className="fixed inset-0 bg-black/50 z-40"
                onClick={() => setIsSidebarOpen(false)}
              />
            )}

            {/* Sidebar Panel */}
            <div
              className={`fixed top-0 left-0 h-full w-64 z-50 transform transition-transform duration-300 ${
                isSidebarOpen ? 'translate-x-0' : '-translate-x-full'
              } ${darkMode ? 'bg-[#1c1c1c] border-r border-[#2c2c2c] text-white' : 'bg-white border-r border-gray-200 text-slate-900'}`}
            >
              <div className="p-4 flex items-center justify-between border-b border-white/5">
                <div className="font-semibold">Menu</div>
                    <button
                  onClick={() => setIsSidebarOpen(false)}
                  className={`h-8 w-8 grid place-items-center rounded ${darkMode ? 'hover:bg-slate-800' : 'hover:bg-slate-100'}`}
                  title="Close"
                >
                  ✕
                </button>
              </div>
              <nav className="p-2">
                {[
                  { key: 'Home', label: 'Home' },
                  { key: 'FretBoard', label: 'Fretboard' },
                  { key: 'Tuner', label: 'Tuner' },
                  { key: 'Jam Mode', label: 'Jam Mode' },
                  { key: 'About', label: 'About' },
                ].map(item => (
                  <button
                    key={item.key}
                    onClick={() => { setPage(item.key); setIsSidebarOpen(false); }}
                    className={`w-full text-left px-3 py-2 rounded mb-1 font-medium transition-colors ${
                      page === item.key
                        ? 'bg-indigo-600 text-white'
                        : darkMode
                        ? 'hover:bg-slate-800 text-slate-200'
                        : 'hover:bg-slate-100 text-slate-800'
                    }`}
                  >
                    {item.label}
                    </button>
                ))}
              </nav>
                </div>

            {/* Main Content */}
            {page === 'Home' && (
              <div className="container mx-auto px-4 py-12">
                <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-3xl font-semibold mb-3`}>Welcome to the FretLab :)</div>
                <div className={`${darkMode ? 'text-slate-300' : 'text-slate-700'} mb-6`}>
                  Hello, my younglings. Friendly reminder to practice your scales and chords EVERYDAY.
                </div>
                {/* image removed from Home */}
                <div className="flex gap-3 mt-6">
                  <button onClick={() => setPage('FretBoard')} className={`${darkMode ? 'bg-indigo-600 hover:bg-indigo-700 text-white' : 'bg-indigo-500 hover:bg-indigo-600 text-white'} px-4 py-2 rounded-lg font-medium`}>
                    Open Fretboard
                  </button>
                  <button onClick={() => setPage('Tuner')} className={`${darkMode ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-slate-300 hover:bg-slate-400 text-slate-900'} px-4 py-2 rounded-lg font-medium`}>
                    Open Tuner
                  </button>
              </div>
            </div>
            )}

            {(page === 'Explorer' || page === 'FretBoard') && (
            <div className="w-full px-2 py-8 flex gap-1">
              {/* Draw Controls Sidebar */}
              <div className={`${darkMode ? 'bg-[#1c1c1c]' : 'bg-white'} rounded-lg p-2 h-fit w-24`}>
                <div className="flex flex-col gap-2">
                  <button
                    onClick={() => setDrawingMode(drawingMode === 'draw' ? null : 'draw')}
                    className={`px-2 py-2 rounded-lg font-medium transition-colors text-sm ${
                      drawingMode === 'draw'
                        ? 'bg-blue-600 text-white'
                        : darkMode
                        ? 'bg-slate-800 hover:bg-slate-700 text-white'
                        : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                    }`}
                    title="Draw"
                  >
                    ✏️Draw
                  </button>

                  <button
                    onClick={() => setDrawingMode(drawingMode === 'erase' ? null : 'erase')}
                    className={`px-2 py-2 rounded-lg font-medium transition-colors text-sm ${
                      drawingMode === 'erase'
                        ? 'bg-red-600 text-white'
                        : darkMode
                        ? 'bg-slate-800 hover:bg-slate-700 text-white'
                        : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                    }`}
                    title="Erase"
                  >
                    🧹Erase
                  </button>

                  <button
                    onClick={() => setDrawings({})}
                    className={`px-2 py-2 rounded-lg font-medium transition-colors text-sm ${
                      darkMode
                        ? 'bg-slate-800 hover:bg-slate-700 text-white'
                        : 'bg-slate-200 hover:bg-slate-300 text-slate-900'
                    }`}
                    title="Clear all"
                  >
                    🔄Clear
                  </button>
                </div>
                <div className={`mt-2 p-2 rounded ${darkMode ? 'bg-[#111]' : 'bg-slate-100'} overflow-hidden`}>
                  <div className={`text-xs mb-2 ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>Metronome</div>
                  <div className="flex items-center gap-2">
                    <input
                      type="number"
                      min="20"
                      max="300"
                      step="1"
                      value={bpm}
                      inputMode="numeric"
                      onChange={(e)=> setBpm(Math.max(20, Math.min(300, parseInt(e.target.value) || 0)))}
                      onBlur={(e)=> setBpm(Math.max(20, Math.min(300, parseInt(e.target.value) || 100)))}
                      className={`w-[72px] px-2 py-1 text-xs rounded ${darkMode ? 'bg-slate-800 text-white border-slate-600' : 'bg-white text-slate-900 border-slate-300'} border`}
                    />
                    {/* BPM label removed */}
                  </div>
                  {/* Slider removed per request */}
                  <div className="flex gap-2 mt-2">
                    {!isMetronomeOn ? (
                      <button onClick={startMetronome} className={`${darkMode ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'} px-2 py-1 rounded text-xs font-medium w-full`}>Start</button>
                    ) : (
                      <button onClick={stopMetronome} className={`${darkMode ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-red-600 hover:bg-red-700 text-white'} px-2 py-1 rounded text-xs font-medium w-full`}>Stop</button>
                    )}
                  </div>
                </div>
              </div>

              <div className="overflow-x-auto flex-1">
                <div className="block w-full">
                  <div className={`${darkMode ? 'bg-[#2a2a2a]' : 'bg-gray-200'} rounded-lg p-8 relative`}>
                    <div className="flex mb-2">
                      <div className="w-16"></div>
                      <div className="flex flex-1">
                      {[...Array(21)].map((_, fret) => {
                        const fretNum = fret + 1;
                        if (fretNum < startFret || fretNum > endFret) return null;
                        return (
                          <div
                            key={fret}
                              className={`text-center text-xs font-semibold ${
                              darkMode ? 'text-slate-400' : 'text-slate-600'
                            }`}
                              style={{ width: `${100 / visibleFretCount}%` }}
                          >
                            {fretNum}
                          </div>
                        );
                      })}
                      </div>
                    </div>

                    {strings.map((string, stringIndex) => (
                      <div key={stringIndex} className="flex items-center mb-1">
                        <div
                          className={`w-14 text-center font-bold ${
                            darkMode ? 'text-slate-200' : 'text-slate-700'
                          }`}
                        >
                          {string.name}
                        </div>

                        <div className="flex flex-1 relative">
                          <div
                            className={`absolute left-0 right-0 top-1/2 transform -translate-y-1/2 ${
                              darkMode ? 'bg-slate-600' : 'bg-slate-400'
                            }`}
                            style={{ height: `${2 + stringIndex * 0.3}px` }}
                          ></div>

                          {[...Array(21)].map((_, fret) => {
                            const fretNum = fret + 1; // Display fret number starting from 1
                            const noteIndex = getNoteAtFret(string.openNote, fretNum);
                            const inScale = isNoteInScale(noteIndex);
                            const isRoot = isRootNote(noteIndex);
                            const degree = getScaleDegree(noteIndex);
                            const isHovered = hoveredNote === `${stringIndex}-${fretNum}`;
                            
                            // Only show frets in the selected range
                            if (fretNum < startFret || fretNum > endFret) return null;

                            const drawKey = `${stringIndex}-${fretNum}`;
                            const isDrawn = drawings[drawKey];
                            
                            return (
                            <div
                              key={fret}
                              className="h-14 flex items-center justify-center relative rounded-lg"
                                style={{ width: `${100 / visibleFretCount}%` }}
                                onMouseEnter={() => setHoveredNote(drawKey)}
                                onMouseLeave={() => setHoveredNote(null)}
                                onClick={() => {
                                  if (drawingMode === 'draw') {
                                    setDrawings({...drawings, [drawKey]: true});
                                  } else if (drawingMode === 'erase') {
                                    const newDrawings = {...drawings};
                                    delete newDrawings[drawKey];
                                    setDrawings(newDrawings);
                                  }
                                }}
                              >
                                {fret > 0 && (
                                  <div
                                    className={`absolute left-0 top-0 bottom-0 w-0.5 ${
                                      darkMode ? 'bg-slate-700' : 'bg-slate-300'
                                    }`}
                                  ></div>
                                )}

                                {/* Drawn note overlay */}
                                {isDrawn && (
                                  <div className="absolute inset-0 border-4 border-yellow-400 rounded-lg pointer-events-none z-20" />
                                )}

                                {(() => {
                                  // First check if chord is selected
                                  if (selectedChord) {
                                    const shouldShow = isToneInChord(noteIndex);
                                    if (!shouldShow) return null;
                                  } else if (!inScale) return null;
                                  
                                  const isChordRootNote = isChordRoot(noteIndex);
                                  const isChordThirdNote = isChordThird(noteIndex);
                                  const isScaleRootNote = isRootNote(noteIndex);
                                  
                                  let bgColor;
                                  if (selectedChord) {
                                    if (isChordRootNote) bgColor = rootColor;
                                    else if (isChordThirdNote) bgColor = thirdColor;
                                    else bgColor = noteColor;
                                  } else {
                                    bgColor = isScaleRootNote ? rootColor : noteColor;
                                  }
                                  
                                  return (
                                    <div
                                      className={`relative z-10 w-10 h-10 rounded-full flex items-center justify-center text-xs font-bold cursor-default transition-all ${isHovered ? 'scale-110 shadow-lg' : 'shadow-md'}`}
                                      style={{ 
                                        backgroundColor: bgColor,
                                        color: '#ffffff'
                                      }}
                                    >
                                      {showDegrees ? formatDegree(degree, noteIndex) : notes[noteIndex]}
                                    </div>
                                  );
                                })()}

                                {stringIndex === 2 && (fretNum === 3 || fretNum === 5 || fretNum === 7 || fretNum === 9 || fretNum === 15 || fretNum === 17 || fretNum === 19 || fretNum === 21) && (
                                  <div
                                    className={`absolute w-2 h-2 rounded-full ${
                                      darkMode ? 'bg-slate-600' : 'bg-slate-400'
                                    } opacity-50`}
                                    style={{ top: '50%', transform: 'translateY(-50%)' }}
                                  ></div>
                                )}
                                {stringIndex === 3 && fretNum === 12 && (
                                  <div
                                    className={`absolute w-2 h-2 rounded-full ${
                                      darkMode ? 'bg-slate-600' : 'bg-slate-400'
                                    } opacity-50`}
                                    style={{ top: '30%', transform: 'translateY(-50%)' }}
                                  ></div>
                                )}
                                {stringIndex === 2 && fretNum === 12 && (
                                  <div
                                    className={`absolute w-2 h-2 rounded-full ${
                                      darkMode ? 'bg-slate-600' : 'bg-slate-400'
                                    } opacity-50`}
                                    style={{ top: '70%', transform: 'translateY(-50%)' }}
                                  ></div>
                                )}
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
            )}

            {page === 'Tuner' && (
              <div className="container mx-auto px-4 py-12">
                <div className="flex items-center justify-between mb-6">
                  <div className="flex items-center gap-3">
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-2xl font-semibold`}>Guitar Tuner</div>
                    <label className={`flex items-center gap-2 text-sm ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>
                      <input type="checkbox" checked={autoDetectString} onChange={(e)=> setAutoDetectString(e.target.checked)} />
                      Auto string detect
                    </label>
                  </div>
                  <div className="flex gap-2">
                    {!isTunerOn ? (
                      <button onClick={startTuner} className={`${darkMode ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'} px-4 py-2 rounded-lg font-medium`}>
                        Start
                      </button>
                    ) : (
                      <button onClick={stopTuner} className={`${darkMode ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-red-600 hover:bg-red-700 text-white'} px-4 py-2 rounded-lg font-medium`}>
                        Stop
                      </button>
                    )}
                  </div>
                </div>

                {tunerError && (
                  <div className={`${darkMode ? 'bg-red-900/40 text-red-200 border-red-700' : 'bg-red-100 text-red-800 border-red-300'} border rounded p-3 mb-4`}>
                    Microphone error: {tunerError}
                  </div>
                )}

                <div className={`${darkMode ? 'bg-[#1c1c1c]' : 'bg-white'} rounded-xl border ${darkMode ? 'border-[#2c2c2c]' : 'border-gray-200'} p-6 grid grid-cols-1 md:grid-cols-3 gap-6`}>
                  <div className="md:col-span-2 flex flex-col items-center justify-center">
                    <div className="relative w-64 h-32">
                      <div className="absolute inset-0 flex items-end justify-center">
                        <div className={`${darkMode ? 'text-slate-400' : 'text-slate-600'} text-xs`}>-50¢</div>
                        <div className="flex-1" />
                        <div className={`${darkMode ? 'text-slate-400' : 'text-slate-600'} text-xs`}>+50¢</div>
                      </div>
                      {/* Green in-tune zone (±5¢) */}
                      <div className="absolute left-1/2 bottom-0 -translate-x-1/2 w-8 h-24 bg-green-500/25 rounded" />
                      <div className="absolute left-1/2 bottom-0 -translate-x-1/2 w-1 h-24 bg-indigo-600 origin-bottom rounded"
                        style={{ transform: `translateX(-50%) rotate(${(tunerCents / 50) * 45}deg)` }}
                      />
                      <div className="absolute left-0 right-0 bottom-0 h-1.5 ${darkMode ? 'bg-slate-700' : 'bg-slate-300'} rounded" />
                    </div>
                    <div className="mt-6 text-center">
                      <div className={`${darkMode ? 'text-slate-300' : 'text-slate-700'} text-sm`}>Detected</div>
                      <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-5xl font-bold leading-tight`}>{tunerNote}</div>
                      <div className={`${darkMode ? 'text-slate-300' : 'text-slate-700'} text-sm mt-1`}>{tunerFreq ? tunerFreq.toFixed(1) + ' Hz' : '--'}</div>
                      <div className={`mt-2 text-sm font-medium ${Math.abs(tunerCents) <= 5 ? 'text-green-500' : 'text-amber-500'}`}>
                        {Math.abs(tunerCents) <= 5 ? 'In tune' : tunerCents < 0 ? `${Math.abs(tunerCents)}¢ flat` : `${tunerCents}¢ sharp`}
                      </div>
                      {/* Target string indicator with hold progress */}
                      <div className="mt-4 flex flex-col items-center gap-1">
                        <div className={`${darkMode ? 'text-slate-200' : 'text-slate-900'} text-sm font-semibold`}>
                          Target: {tuningPresets[tuning][selectedString]}
                        </div>
                        <div className="w-40 h-2 rounded-full overflow-hidden border border-black/10">
                          {(() => {
                            const start = stringHoldStart;
                            const progress = stringConfirmed ? 1 : (start ? Math.min(1, (performance.now() - start) / 3000) : 0);
                            const barColor = stringConfirmed ? 'bg-green-500' : 'bg-amber-500';
                            return <div className={`${barColor} h-full`} style={{ width: `${progress * 100}%` }} />;
                          })()}
                        </div>
                      </div>
                    </div>
                  </div>
                  {/* Right column: Headstock + Tuning */}
                  <div className="space-y-3">
                    <div className={`text-sm ${darkMode ? 'text-slate-200' : 'text-slate-900'} font-semibold`}>Tuning</div>
                    <select
                      value={tuning}
                      onChange={(e)=> setTuning(e.target.value)}
                      className={`w-full px-3 h-9 text-sm rounded-lg ${darkMode ? 'bg-slate-800 text-white border-slate-600' : 'bg-white text-slate-900 border-slate-300'} border focus:outline-none`}
                    >
                      <option value="standard">Standard (E A D G B E)</option>
                      <option value="dropD">Drop D (D A D G B E)</option>
                      <option value="halfStepDown">Half-step Down (D# G# C# F# A# D#)</option>
                    </select>

                    <div className={`mt-2 ${darkMode ? 'bg-[#0f0f0f] border-[#2c2c2c]' : 'bg-slate-100 border-slate-300'} border rounded-lg p-3`}>
                      <div className={`text-xs mb-2 ${darkMode ? 'text-slate-300' : 'text-slate-700'}`}>Headstock</div>
                      {/* Acoustic-style headstock: 3+3 tuners */}
                      <div className="relative w-72 h-44 mx-auto">
                        {/* Wood headstock body */}
                        <div className={`absolute left-1/2 -translate-x-1/2 top-2 bottom-2 w-20 rounded-[24px] ${darkMode ? 'bg-[#2a1b10]' : 'bg-amber-800'} shadow-inner`} />
                        {/* Nut */}
                        <div className={`${darkMode ? 'bg-slate-300' : 'bg-slate-200'} absolute left-1/2 -translate-x-1/2 bottom-2 h-1 w-24 rounded`} />

                        {(() => {
                          // 3 pegs per side (left/right), bottom to top is low->high
                          const positions = [
                            { idx: 0, side: 'left', top: '76%' },
                            { idx: 1, side: 'left', top: '50%' },
                            { idx: 2, side: 'left', top: '24%' },
                            { idx: 3, side: 'right', top: '24%' }, // G (top)
                            { idx: 4, side: 'right', top: '50%' }, // B (middle)
                            { idx: 5, side: 'right', top: '76%' }, // E (bottom)
                          ];

                          return positions.map((p) => {
                            const open = tuningPresets[tuning][p.idx];
                            const isSelected = p.idx === selectedString;
                            const pillClass = isSelected
                              ? (stringConfirmed
                                  ? 'bg-green-600 text-white border-green-600'
                                  : 'bg-amber-500 text-white border-amber-500')
                              : `${darkMode ? 'bg-slate-800 text-white border-slate-600' : 'bg-white text-slate-900 border-slate-300'}`;
                            const pegSideClass = p.side === 'left' ? 'left-3' : 'right-3';
                            const labelSideClass = p.side === 'left' ? 'left-12' : 'right-12';
                            const stringAnchorClass = p.side === 'left' ? 'left-[88px]' : 'right-[88px]';
                            return (
                              <div key={p.idx} className="absolute" style={{ top: p.top, left: 0, right: 0 }}>
                                {/* String segment to nut */}
                                <div className={`absolute ${stringAnchorClass} h-0.5 ${darkMode ? 'bg-slate-500' : 'bg-slate-400'} w-16`} />
                                {/* Peg */}
                                <div className={`absolute ${pegSideClass} -translate-y-1/2`}>
                                  <div className={`${darkMode ? 'bg-zinc-300' : 'bg-zinc-200'} w-4 h-4 rounded-full shadow`} />
                                </div>
                                {/* Clickable note label */}
                                <button
                                  type="button"
                                  className={`absolute ${labelSideClass} -translate-y-1/2 px-2 py-0.5 text-xs rounded-full border ${pillClass}`}
                                  onClick={() => {
                                    setSelectedString(p.idx);
                                    playStringSound(p.idx);
                                  }}
                                >
                                  {open}
                                </button>
                              </div>
                            );
                          });
                        })()}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            

            {page === 'About' && (
              <div className="container mx-auto px-4 py-12">
                <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-2xl font-semibold mb-4`}>About</div>
                <div className="text-white">Made by Nathan Kwon</div>
              </div>
            )}

            {page === 'Jam Mode' && (
              <div className="container mx-auto px-4 py-12 max-w-5xl">
                <div className={`${darkMode ? 'text-white' : 'text-slate-900'} text-2xl font-semibold mb-6`}>Jam Mode</div>

                {/* Countdown Overlay */}
                {isCountdownActive && countdown !== null && (
                  <div className="fixed inset-0 z-40 pointer-events-none flex items-center justify-center">
                    <div className={`text-[8rem] md:text-[10rem] font-extrabold drop-shadow ${darkMode ? 'text-blue-400' : 'text-blue-600'}`}>
                      {countdown}
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* LEFT: Key + Progression */}
                  <div className={`${darkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-300'} border rounded-lg p-4`}>
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium mb-3`}>Key</div>
                    <select
                      value={selectedKey}
                      onChange={(e) => setSelectedKey(e.target.value)}
                      className={`w-full px-3 py-2 rounded border ${darkMode ? 'bg-slate-700 border-slate-600 text-white' : 'bg-white border-slate-300 text-slate-900'}`}
                      disabled={isRecording || isCountdownActive}
                    >
                      {musicalKeys.map((key) => (
                        <option key={key} value={key}>{key}</option>
                      ))}
                    </select>
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium mt-5 mb-3`}>Chord Progression</div>
                    <select
                      value={selectedProgression ?? ''}
                      onChange={(e) => setSelectedProgression(e.target.value === '' ? null : parseInt(e.target.value))}
                      className={`w-full px-3 py-2 rounded border ${darkMode ? 'bg-slate-700 border-slate-600 text-white' : 'bg-white border-slate-300 text-slate-900'}`}
                    >
                      <option value="">None</option>
                      {chordProgressions.map((prog, idx) => (
                        <option key={idx} value={idx}>{prog.name}</option>
                      ))}
                    </select>
                    {selectedProgression !== null && chordProgressions[selectedProgression].romans.length > 0 && (
                      <div className="mt-3 flex flex-wrap gap-2">
                        {chordsForProgression(selectedKey, chordProgressions[selectedProgression].romans).map((chord, idx) => (
                          <div key={idx} className={`px-3 py-1 rounded ${darkMode ? 'bg-slate-700 text-white' : 'bg-slate-200 text-slate-900'} font-medium`}>
                            {chord}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>

                  {/* RIGHT: Metronome */}
                  <div className={`${darkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-300'} border rounded-lg p-4`}>
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium mb-3`}>Metronome</div>
                    <div className="flex items-center gap-3 mb-4">
                      <input
                        type="number"
                        min={20}
                        max={300}
                        value={bpm}
                        onChange={(e) => {
                          const v = Math.max(20, Math.min(300, Number(e.target.value) || 0));
                          setBpm(v);
                        }}
                        className={`w-24 px-3 py-2 rounded border ${darkMode ? 'bg-slate-700 border-slate-600 text-white' : 'bg-white border-slate-300 text-slate-900'}`}
                      />
                      <button
                        onClick={() => setIsMetronomeEnabled(!isMetronomeEnabled)}
                        className={`px-4 py-2 rounded font-medium ${isMetronomeEnabled ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'}`}
                      >
                        {isMetronomeEnabled ? 'Disable' : 'Enable'}
                      </button>
                    </div>
                    <div className={`text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>Countdown: 1 bar at {bpm} BPM (starts metronome when recording)</div>
                  </div>
                </div>

                {/* Bottom Center Controls */}
                <div className="mt-8 flex flex-col items-center">
                  <button
                    onClick={() => (isRecording || isCountdownActive) ? stopRecording() : startRecording()}
                    className={`px-7 py-3 rounded-lg font-semibold ${isRecording || isCountdownActive ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-blue-600 hover:bg-blue-700 text-white'}`}
                    disabled={isCropping}
                  >
                    {isCountdownActive ? '⏹ Cancel Countdown' : isRecording ? '⏹ Stop Recording' : '● Start Recording'}
                  </button>

                  <div className="mt-4 flex items-center gap-3">
                    <button
                      onClick={() => isPlaying ? stopPlayback() : playRecordedAudio()}
                      className={`px-5 py-2 rounded ${isPlaying ? 'bg-orange-600 hover:bg-orange-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white'}`}
                    >
                      {isPlaying ? '⏸ Pause' : '▶ Play'}
                    </button>
                    <button
                      onClick={() => { const nl = !isLooping; setIsLooping(nl); jamModeRef.current.shouldLoop = nl; }}
                      className={`px-5 py-2 rounded ${isLooping ? 'bg-purple-600 hover:bg-purple-700 text-white' : (darkMode ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-slate-200 hover:bg-slate-300 text-slate-900')}`}
                    >
                      {isLooping ? '🔁 Looping' : '🔁 Loop'}
                    </button>
                    <button
                      onClick={() => setShowCropUI(!showCropUI)}
                      className={`px-5 py-2 rounded ${darkMode ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-slate-200 hover:bg-slate-300 text-slate-900'}`}
                    >
                      ✂ Edit
                    </button>
                    <button
                      onClick={() => saveLoopToDb()}
                      disabled={!recordedAudio}
                      className={`px-5 py-2 rounded ${recordedAudio ? 'bg-teal-600 hover:bg-teal-700 text-white' : (darkMode ? 'bg-slate-700 text-slate-400' : 'bg-slate-200 text-slate-400')}`}
                    >
                      💾 Save
                    </button>
                  </div>
                </div>

                {/* Trim UI (Waveform Editor) */}
                {showCropUI && recordedAudio && (
                  <div className={`${darkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-300'} border rounded-lg p-4 mt-6 max-w-3xl mx-auto w-full`}>
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium mb-2`}>Trim</div>
                    <div className={`text-xs mb-3 ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>
                      Drag the handles to remove audio from the beginning or end.
                    </div>

                    <div className={`${darkMode ? 'bg-slate-900' : 'bg-slate-100'} rounded-md p-3 border ${darkMode ? 'border-slate-700' : 'border-slate-300'}`}>
                      <canvas id="waveform-canvas" width="800" height="140" className="w-full h-[140px] rounded bg-transparent cursor-pointer select-none touch-none" />
                    </div>

                    <div className="flex items-center gap-3 mt-4">
                      <button onClick={cropAudio} disabled={isCropping || isRecording}
                        className={`px-5 py-2 rounded ${isCropping || isRecording ? 'bg-slate-400 text-white' : 'bg-blue-600 hover:bg-blue-700 text-white'}`}>
                        {isCropping ? 'Trimming...' : 'Apply Trim'}
                      </button>
                      <button onClick={undoTrim} disabled={undoStack.length === 0 || isCropping || isRecording}
                        className={`px-5 py-2 rounded ${undoStack.length === 0 || isCropping || isRecording ? 'bg-slate-400 text-white' : 'bg-amber-600 hover:bg-amber-700 text-white'}`}>
                        ↺ Undo
                      </button>
                      <div className={`text-sm ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>Duration: {audioDuration.toFixed(2)}s</div>
                    </div>
                  </div>
                )}

                {/* Saved Loops */}
                {savedLoops && savedLoops.length > 0 && (
                  <div className="mt-6 max-w-5xl mx-auto w-full">
                    <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium mb-2`}>Saved Loops</div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                      {savedLoops.map(loop => (
                        <div key={loop.id} className={`${darkMode ? 'bg-slate-800 border-slate-700' : 'bg-white border-slate-300'} border rounded p-3 flex items-center justify-between`}>
                          <div>
                            <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium text-sm`}>{loop.name || 'Untitled Loop'}</div>
                            <div className={`text-xs ${darkMode ? 'text-slate-400' : 'text-slate-600'}`}>
                              {loop.progressionName ? `${loop.progressionName} • ` : ''}Key: {loop.key} • BPM: {loop.bpm}
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <button onClick={() => loadLoop(loop.id)} className={`px-3 py-1.5 rounded ${darkMode ? 'bg-slate-700 hover:bg-slate-600 text-white' : 'bg-slate-200 hover:bg-slate-300 text-slate-900'}`}>Load</button>
                            <button onClick={() => deleteLoop(loop.id)} className={`px-3 py-1.5 rounded bg-red-600 hover:bg-red-700 text-white`}>Delete</button>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Chords in Scale - hidden on Home, Tuner, About, and Jam Mode */}
            {page !== 'Home' && page !== 'Tuner' && page !== 'About' && page !== 'Jam Mode' && (
            <div className="container mx-auto px-4 py-8">
              <div className="mt-6">
                <div className="flex items-center justify-between mb-3">
                  <h3 className={`${darkMode ? 'text-white' : 'text-slate-900'} font-semibold`}>
                    Chords in Scale ({chordType})
                  </h3>
                  {selectedChord && (
                    <button
                      onClick={() => setSelectedChord(null)}
                      className={`px-3 py-1.5 text-sm rounded-lg font-medium transition-colors ${
                        darkMode
                          ? 'bg-slate-700 hover:bg-slate-600 text-white'
                          : 'bg-slate-300 hover:bg-slate-400 text-slate-900'
                      }`}
                    >
                      Clear Selection
                    </button>
                  )}
                </div>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                  {buildDiatonicChords.map((ch) => (
                    <div 
                      key={`${ch.degree}-${ch.name}`} 
                      className={`${darkMode ? 'bg-[#2a2a2a]' : 'bg-gray-200'} rounded-lg p-3 cursor-pointer transition-all hover:scale-105 ${
                        selectedChord && selectedChord.name === ch.name ? 'ring-2 ring-yellow-400' : ''
                      }`}
                      onClick={() => setSelectedChord(ch)}
                    >
                      <div className="flex items-center justify-between">
                        <div className={`${darkMode ? 'text-white' : 'text-slate-900'} font-medium`}>
                          {ch.degree}. {ch.name}
                        </div>
                        <div className="flex -space-x-1">
                          {ch.pcs.map((pc, idx) => (
                            <div key={idx} className="w-6 h-6 rounded-full border border-black/10 flex items-center justify-center text-[10px] font-bold"
                              style={{ backgroundColor: idx===0 ? rootColor : (idx===1 ? thirdColor : noteColor), color: '#fff' }}
                            >
                              {notes[pc]}
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
            )}
          </div>
        );
      };

      window.GuitarScaleExplorer = GuitarScaleExplorer;
    </script>

    <!-- Mount the component with error handling -->
    <script type="text/babel">
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false, error: null };
        }
        static getDerivedStateFromError(error) {
          return { hasError: true, error };
        }
        componentDidCatch(error, info) {
          console.error('Render error:', error, info);
        }
        render() {
          if (this.state.hasError) {
            return (
              <div className="min-h-screen flex items-center justify-center bg-red-50 p-6">
                <div className="max-w-lg w-full bg-white shadow rounded-lg p-6 border border-red-200">
                  <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
                  <p className="text-sm text-red-600">{String(this.state.error)}</p>
                  <button
                    className="mt-4 px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700"
                    onClick={() => window.location.reload()}
                  >
                    Reload
                  </button>
                </div>
              </div>
            );
          }
          return this.props.children;
        }
      }

      function mountApp() {
        try {
          if (!window.GuitarScaleExplorer) {
            throw new Error('Component not loaded yet.');
          }
          const container = document.getElementById('root');
          if (!container) {
            throw new Error('Root container not found.');
          }
          const root = ReactDOM.createRoot(container);
          root.render(
            <ErrorBoundary>
              <GuitarScaleExplorer />
            </ErrorBoundary>
          );
        } catch (e) {
          console.error(e);
          const container = document.getElementById('root');
          if (container) {
            container.innerHTML = `
              <div style="min-height:100vh;display:flex;align-items:center;justify-content:center;background:#fff1f2;padding:24px;">
                <div style="max-width:640px;width:100%;background:#ffffff;border:1px solid #fecaca;border-radius:12px;padding:16px;font-family:ui-sans-serif,system-ui;">
                  <div style="font-weight:600;color:#b91c1c;margin-bottom:8px;">Failed to load the app</div>
                  <div style="color:#991b1b;font-size:14px;">${String(e)}</div>
                </div>
              </div>`;
          }
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', mountApp);
      } else {
        mountApp();
      }
    </script>
  </body>
  </html>


